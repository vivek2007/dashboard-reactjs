{"ast":null,"code":"import { AutoSizer, List } from 'react-virtualized';\nimport isEqual from 'lodash.isequal';\nimport withScrolling, { createScrollingComponent, createVerticalStrength, createHorizontalStrength } from 'frontend-collective-react-dnd-scrollzone';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport React, { Component, Children, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { DragSource, DropTarget, DndProvider, DndContext } from 'react-dnd';\nimport { findDOMNode } from 'react-dom';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  } // Binding \"this\" is important for shallow renderer support.\n\n\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n} // React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\n\n\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component$$1) {\n  var prototype = Component$$1.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (typeof Component$$1.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {\n    return Component$$1;\n  } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n\n\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n\n  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n    var componentName = Component$$1.displayName || Component$$1.name;\n    var newApiName = typeof Component$$1.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') + '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks');\n  } // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n\n\n  if (typeof Component$$1.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  } // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n\n\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component$$1;\n} // very simple className utility for creating a classname string...\n// Falsy arguments are ignored:\n//\n// const active = true\n// const className = classnames(\n//    \"class1\",\n//    !active && \"class2\",\n//    active && \"class3\"\n// ); // returns -> class1 class3\";\n//\n\n\nfunction classnames() {\n  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n    classes[_key] = arguments[_key];\n  } // Use Boolean constructor as a filter callback\n  // Allows for loose type truthy/falsey checks\n  // Boolean(\"\") === false;\n  // Boolean(false) === false;\n  // Boolean(undefined) === false;\n  // Boolean(null) === false;\n  // Boolean(0) === false;\n  // Boolean(\"classname\") === true;\n\n\n  return classes.filter(Boolean).join(' ');\n}\n\nvar TreeNode = /*#__PURE__*/function (_Component) {\n  _inherits(TreeNode, _Component);\n\n  function TreeNode() {\n    _classCallCheck(this, TreeNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TreeNode).apply(this, arguments));\n  }\n\n  _createClass(TreeNode, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          listIndex = _this$props.listIndex,\n          swapFrom = _this$props.swapFrom,\n          swapLength = _this$props.swapLength,\n          swapDepth = _this$props.swapDepth,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          lowerSiblingCounts = _this$props.lowerSiblingCounts,\n          connectDropTarget = _this$props.connectDropTarget,\n          isOver = _this$props.isOver,\n          draggedNode = _this$props.draggedNode,\n          canDrop = _this$props.canDrop,\n          treeIndex = _this$props.treeIndex,\n          treeId = _this$props.treeId,\n          getPrevRow = _this$props.getPrevRow,\n          node = _this$props.node,\n          path = _this$props.path,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"listIndex\", \"swapFrom\", \"swapLength\", \"swapDepth\", \"scaffoldBlockPxWidth\", \"lowerSiblingCounts\", \"connectDropTarget\", \"isOver\", \"draggedNode\", \"canDrop\", \"treeIndex\", \"treeId\", \"getPrevRow\", \"node\", \"path\", \"rowDirection\"]);\n\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null; // Construct the scaffold representing the structure of the tree\n\n      var scaffoldBlockCount = lowerSiblingCounts.length;\n      var scaffold = [];\n      lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n        var lineClass = '';\n\n        if (lowerSiblingCount > 0) {\n          // At this level in the tree, the nodes had sibling nodes further down\n          if (listIndex === 0) {\n            // Top-left corner of the tree\n            // +-----+\n            // |     |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineHalfVerticalBottom';\n          } else if (i === scaffoldBlockCount - 1) {\n            // Last scaffold block in the row, right before the row content\n            // +--+--+\n            // |  |  |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineFullVertical';\n          } else {\n            // Simply connecting the line extending down to the next sibling on this level\n            // +--+--+\n            // |  |  |\n            // |  |  |\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineFullVertical';\n          }\n        } else if (listIndex === 0) {\n          // Top-left corner of the tree, but has no siblings\n          // +-----+\n          // |     |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfHorizontalRight';\n        } else if (i === scaffoldBlockCount - 1) {\n          // The last or only node in this level of the tree\n          // +--+--+\n          // |  |  |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfVerticalTop rst__lineHalfHorizontalRight';\n        }\n\n        scaffold.push(React.createElement(\"div\", {\n          key: \"pre_\".concat(1 + i),\n          style: {\n            width: scaffoldBlockPxWidth\n          },\n          className: classnames('rst__lineBlock', lineClass, rowDirectionClass)\n        }));\n\n        if (treeIndex !== listIndex && i === swapDepth) {\n          // This row has been shifted, and is at the depth of\n          // the line pointing to the new destination\n          var highlightLineClass = '';\n\n          if (listIndex === swapFrom + swapLength - 1) {\n            // This block is on the bottom (target) line\n            // This block points at the target block (where the row will go when released)\n            highlightLineClass = 'rst__highlightBottomLeftCorner';\n          } else if (treeIndex === swapFrom) {\n            // This block is on the top (source) line\n            highlightLineClass = 'rst__highlightTopLeftCorner';\n          } else {\n            // This block is between the bottom and top\n            highlightLineClass = 'rst__highlightLineVertical';\n          }\n\n          var _style;\n\n          if (rowDirection === 'rtl') {\n            _style = {\n              width: scaffoldBlockPxWidth,\n              right: scaffoldBlockPxWidth * i\n            };\n          } else {\n            // Default ltr\n            _style = {\n              width: scaffoldBlockPxWidth,\n              left: scaffoldBlockPxWidth * i\n            };\n          }\n\n          scaffold.push(React.createElement(\"div\", {\n            // eslint-disable-next-line react/no-array-index-key\n            key: i,\n            style: _style,\n            className: classnames('rst__absoluteLineBlock', highlightLineClass, rowDirectionClass)\n          }));\n        }\n      });\n      var style;\n\n      if (rowDirection === 'rtl') {\n        style = {\n          right: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      } else {\n        // Default ltr\n        style = {\n          left: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      }\n\n      return connectDropTarget(React.createElement(\"div\", _extends({}, otherProps, {\n        className: classnames('rst__node', rowDirectionClass)\n      }), scaffold, React.createElement(\"div\", {\n        className: \"rst__nodeContent\",\n        style: style\n      }, Children.map(children, function (child) {\n        return cloneElement(child, {\n          isOver: isOver,\n          canDrop: canDrop,\n          draggedNode: draggedNode\n        });\n      }))));\n    }\n  }]);\n\n  return TreeNode;\n}(Component);\n\nTreeNode.defaultProps = {\n  swapFrom: null,\n  swapDepth: null,\n  swapLength: null,\n  canDrop: false,\n  draggedNode: null,\n  rowDirection: 'ltr'\n};\nTreeNode.propTypes = {\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  swapFrom: PropTypes.number,\n  swapDepth: PropTypes.number,\n  swapLength: PropTypes.number,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  lowerSiblingCounts: PropTypes.arrayOf(PropTypes.number).isRequired,\n  listIndex: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  // used in dndManager\n  getPrevRow: PropTypes.func.isRequired,\n  node: PropTypes.shape({}).isRequired,\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\n\nfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n  var targetIndex = _ref.targetIndex,\n      node = _ref.node,\n      currentIndex = _ref.currentIndex,\n      getNodeKey = _ref.getNodeKey,\n      _ref$path = _ref.path,\n      path = _ref$path === void 0 ? [] : _ref$path,\n      _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n      lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,\n      _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n      ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,\n      _ref$isPseudoRoot = _ref.isPseudoRoot,\n      isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot; // The pseudo-root is not considered in the path\n\n  var selfPath = !isPseudoRoot ? _toConsumableArray(path).concat([getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]) : []; // Return target node when found\n\n  if (currentIndex === targetIndex) {\n    return {\n      node: node,\n      lowerSiblingCounts: lowerSiblingCounts,\n      path: selfPath\n    };\n  } // Add one and continue for nodes with no children or hidden children\n\n\n  if (!node.children || ignoreCollapsed && node.expanded !== true) {\n    return {\n      nextIndex: currentIndex + 1\n    };\n  } // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n\n\n  var childIndex = currentIndex + 1;\n  var childCount = node.children.length;\n\n  for (var i = 0; i < childCount; i += 1) {\n    var result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed: ignoreCollapsed,\n      getNodeKey: getNodeKey,\n      targetIndex: targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  } // If the target node is not found, return the farthest traversed index\n\n\n  return {\n    nextIndex: childIndex\n  };\n}\n\nfunction getDescendantCount(_ref2) {\n  var node = _ref2.node,\n      _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n      ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;\n  return getNodeDataAtTreeIndexOrNextIndex({\n    getNodeKey: function getNodeKey() {},\n    ignoreCollapsed: ignoreCollapsed,\n    node: node,\n    currentIndex: 0,\n    targetIndex: -1\n  }).nextIndex - 1;\n}\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction walkDescendants(_ref3) {\n  var callback = _ref3.callback,\n      getNodeKey = _ref3.getNodeKey,\n      ignoreCollapsed = _ref3.ignoreCollapsed,\n      _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n      isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,\n      node = _ref3.node,\n      _ref3$parentNode = _ref3.parentNode,\n      parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,\n      currentIndex = _ref3.currentIndex,\n      _ref3$path = _ref3.path,\n      path = _ref3$path === void 0 ? [] : _ref3$path,\n      _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n      lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou; // The pseudo-root is not considered in the path\n\n  var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = isPseudoRoot ? null : {\n    node: node,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  if (!isPseudoRoot) {\n    var callbackResult = callback(selfInfo); // Cut walk short if the callback returned false\n\n    if (callbackResult === false) {\n      return false;\n    }\n  } // Return self on nodes with no children or hidden children\n\n\n  if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return currentIndex;\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = node.children.length;\n\n  if (typeof node.children !== 'function') {\n    for (var i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n        path: selfPath\n      }); // Cut walk short if the callback returned false\n\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction mapDescendants(_ref4) {\n  var callback = _ref4.callback,\n      getNodeKey = _ref4.getNodeKey,\n      ignoreCollapsed = _ref4.ignoreCollapsed,\n      _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n      isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,\n      node = _ref4.node,\n      _ref4$parentNode = _ref4.parentNode,\n      parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,\n      currentIndex = _ref4.currentIndex,\n      _ref4$path = _ref4.path,\n      path = _ref4$path === void 0 ? [] : _ref4$path,\n      _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n      lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;\n\n  var nextNode = _objectSpread({}, node); // The pseudo-root is not considered in the path\n\n\n  var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n    node: nextNode,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = {\n    node: nextNode,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  }; // Return self on nodes with no children or hidden children\n\n  if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = nextNode.children.length;\n\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map(function (child, i) {\n      var mapResult = mapDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\n\n\nfunction getVisibleNodeCount(_ref5) {\n  var treeData = _ref5.treeData;\n\n  var traverse = function traverse(node) {\n    if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n      return 1;\n    }\n\n    return 1 + node.children.reduce(function (total, currentNode) {\n      return total + traverse(currentNode);\n    }, 0);\n  };\n\n  return treeData.reduce(function (total, currentNode) {\n    return total + traverse(currentNode);\n  }, 0);\n}\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\n\n\nfunction getVisibleNodeInfoAtIndex(_ref6) {\n  var treeData = _ref6.treeData,\n      targetIndex = _ref6.index,\n      getNodeKey = _ref6.getNodeKey;\n\n  if (!treeData || treeData.length < 1) {\n    return null;\n  } // Call the tree traversal with a pseudo-root node\n\n\n  var result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex: targetIndex,\n    getNodeKey: getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\n\n\nfunction walk(_ref7) {\n  var treeData = _ref7.treeData,\n      getNodeKey = _ref7.getNodeKey,\n      callback = _ref7.callback,\n      _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n      ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction map(_ref8) {\n  var treeData = _ref8.treeData,\n      getNodeKey = _ref8.getNodeKey,\n      callback = _ref8.callback,\n      _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n      ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction toggleExpandedForAll(_ref9) {\n  var treeData = _ref9.treeData,\n      _ref9$expanded = _ref9.expanded,\n      expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;\n  return map({\n    treeData: treeData,\n    callback: function callback(_ref10) {\n      var node = _ref10.node;\n      return _objectSpread({}, node, {\n        expanded: expanded\n      });\n    },\n    getNodeKey: function getNodeKey(_ref11) {\n      var treeIndex = _ref11.treeIndex;\n      return treeIndex;\n    },\n    ignoreCollapsed: false\n  });\n}\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\n\nfunction changeNodeAtPath(_ref12) {\n  var treeData = _ref12.treeData,\n      path = _ref12.path,\n      newNode = _ref12.newNode,\n      getNodeKey = _ref12.getNodeKey,\n      _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n      ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;\n  var RESULT_MISS = 'RESULT_MISS';\n\n  var traverse = function traverse(_ref13) {\n    var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n        isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,\n        node = _ref13.node,\n        currentTreeIndex = _ref13.currentTreeIndex,\n        pathIndex = _ref13.pathIndex;\n\n    if (!isPseudoRoot && getNodeKey({\n      node: node,\n      treeIndex: currentTreeIndex\n    }) !== path[pathIndex]) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function' ? newNode({\n        node: node,\n        treeIndex: currentTreeIndex\n      }) : newNode;\n    }\n\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.');\n    }\n\n    var nextTreeIndex = currentTreeIndex + 1;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      var _result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      }); // If the result went down the correct path\n\n\n      if (_result !== RESULT_MISS) {\n        if (_result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return _objectSpread({}, node, {\n            children: _toConsumableArray(node.children.slice(0, i)).concat([_result], _toConsumableArray(node.children.slice(i + 1)))\n          });\n        } // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n\n\n        return _objectSpread({}, node, {\n          children: _toConsumableArray(node.children.slice(0, i)).concat(_toConsumableArray(node.children.slice(i + 1)))\n        });\n      }\n\n      nextTreeIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    }\n\n    return RESULT_MISS;\n  }; // Use a pseudo-root node in the beginning traversal\n\n\n  var result = traverse({\n    node: {\n      children: treeData\n    },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.');\n  }\n\n  return result.children;\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\n\n\nfunction removeNodeAtPath(_ref14) {\n  var treeData = _ref14.treeData,\n      path = _ref14.path,\n      getNodeKey = _ref14.getNodeKey,\n      _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n      ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;\n  return changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: null // Delete the node\n\n  });\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\n\n\nfunction removeNode(_ref15) {\n  var treeData = _ref15.treeData,\n      path = _ref15.path,\n      getNodeKey = _ref15.getNodeKey,\n      _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n      ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;\n  var removedNode = null;\n  var removedTreeIndex = null;\n  var nextTreeData = changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: function newNode(_ref16) {\n      var node = _ref16.node,\n          treeIndex = _ref16.treeIndex; // Store the target node and delete it from the tree\n\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n      return null;\n    }\n  });\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\n\n\nfunction getNodeAtPath(_ref17) {\n  var treeData = _ref17.treeData,\n      path = _ref17.path,\n      getNodeKey = _ref17.getNodeKey,\n      _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n      ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;\n  var foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData: treeData,\n      path: path,\n      getNodeKey: getNodeKey,\n      ignoreCollapsed: ignoreCollapsed,\n      newNode: function newNode(_ref18) {\n        var node = _ref18.node,\n            treeIndex = _ref18.treeIndex;\n        foundNodeInfo = {\n          node: node,\n          treeIndex: treeIndex\n        };\n        return node;\n      }\n    });\n  } catch (err) {// Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\n\n\nfunction addNodeUnderParent(_ref19) {\n  var treeData = _ref19.treeData,\n      newNode = _ref19.newNode,\n      _ref19$parentKey = _ref19.parentKey,\n      parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,\n      getNodeKey = _ref19.getNodeKey,\n      _ref19$ignoreCollapse = _ref19.ignoreCollapsed,\n      ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,\n      _ref19$expandParent = _ref19.expandParent,\n      expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,\n      _ref19$addAsFirstChil = _ref19.addAsFirstChild,\n      addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;\n\n  if (parentKey === null) {\n    return addAsFirstChild ? {\n      treeData: [newNode].concat(_toConsumableArray(treeData || [])),\n      treeIndex: 0\n    } : {\n      treeData: _toConsumableArray(treeData || []).concat([newNode]),\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  var insertedTreeIndex = null;\n  var hasBeenAdded = false;\n  var changedTreeData = map({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(_ref20) {\n      var node = _ref20.node,\n          treeIndex = _ref20.treeIndex,\n          path = _ref20.path;\n      var key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is\n\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n\n      hasBeenAdded = true;\n\n      var parentNode = _objectSpread({}, node);\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      } // If no children exist yet, just add the single newNode\n\n\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return _objectSpread({}, parentNode, {\n          children: [newNode]\n        });\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function');\n      }\n\n      var nextTreeIndex = treeIndex + 1;\n\n      for (var i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex += 1 + getDescendantCount({\n          node: parentNode.children[i],\n          ignoreCollapsed: ignoreCollapsed\n        });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n      var children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : _toConsumableArray(parentNode.children).concat([newNode]);\n      return _objectSpread({}, parentNode, {\n        children: children\n      });\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.');\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex(_ref21) {\n  var targetDepth = _ref21.targetDepth,\n      minimumTreeIndex = _ref21.minimumTreeIndex,\n      newNode = _ref21.newNode,\n      ignoreCollapsed = _ref21.ignoreCollapsed,\n      expandParent = _ref21.expandParent,\n      _ref21$isPseudoRoot = _ref21.isPseudoRoot,\n      isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,\n      isLastChild = _ref21.isLastChild,\n      node = _ref21.node,\n      currentIndex = _ref21.currentIndex,\n      currentDepth = _ref21.currentDepth,\n      getNodeKey = _ref21.getNodeKey,\n      _ref21$path = _ref21.path,\n      path = _ref21$path === void 0 ? [] : _ref21$path;\n\n  var selfPath = function selfPath(n) {\n    return isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n      node: n,\n      treeIndex: currentIndex\n    })]);\n  }; // If the current position is the only possible place to add, add it\n\n\n  if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function');\n    } else {\n      var extraNodeProps = expandParent ? {\n        expanded: true\n      } : {};\n\n      var _nextNode = _objectSpread({}, node, extraNodeProps, {\n        children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n      });\n\n      return {\n        node: _nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(_nextNode),\n        parentNode: isPseudoRoot ? null : _nextNode\n      };\n    }\n  } // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n\n\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n      return {\n        node: node,\n        nextIndex: currentIndex + 1\n      };\n    } // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n\n\n    var _childIndex = currentIndex + 1;\n\n    var _insertedTreeIndex = null;\n    var insertIndex = null;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (_childIndex >= minimumTreeIndex) {\n        _insertedTreeIndex = _childIndex;\n        insertIndex = i;\n        break;\n      } // Increment the index by the child itself plus the number of descendants it has\n\n\n      _childIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    } // If no valid indices to add the node were found\n\n\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (_childIndex < minimumTreeIndex && !isLastChild) {\n        return {\n          node: node,\n          nextIndex: _childIndex\n        };\n      } // Use the last position in the children array to insert the newNode\n\n\n      _insertedTreeIndex = _childIndex;\n      insertIndex = node.children.length;\n    } // Insert the newNode at the insertIndex\n\n\n    var _nextNode2 = _objectSpread({}, node, {\n      children: _toConsumableArray(node.children.slice(0, insertIndex)).concat([newNode], _toConsumableArray(node.children.slice(insertIndex)))\n    }); // Return node with successful insert result\n\n\n    return {\n      node: _nextNode2,\n      nextIndex: _childIndex,\n      insertedTreeIndex: _insertedTreeIndex,\n      parentPath: selfPath(_nextNode2),\n      parentNode: isPseudoRoot ? null : _nextNode2\n    };\n  } // Skip over nodes with no children or hidden children\n\n\n  if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      node: node,\n      nextIndex: currentIndex + 1\n    };\n  } // Get all descendants\n\n\n  var insertedTreeIndex = null;\n  var pathFragment = null;\n  var parentNode = null;\n  var childIndex = currentIndex + 1;\n  var newChildren = node.children;\n\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map(function (child, i) {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      var mapResult = addNodeAtDepthAndIndex({\n        targetDepth: targetDepth,\n        minimumTreeIndex: minimumTreeIndex,\n        newNode: newNode,\n        ignoreCollapsed: ignoreCollapsed,\n        expandParent: expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey: getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n\n      });\n\n      if ('insertedTreeIndex' in mapResult) {\n        insertedTreeIndex = mapResult.insertedTreeIndex;\n        parentNode = mapResult.parentNode;\n        pathFragment = mapResult.parentPath;\n      }\n\n      childIndex = mapResult.nextIndex;\n      return mapResult.node;\n    });\n  }\n\n  var nextNode = _objectSpread({}, node, {\n    children: newChildren\n  });\n\n  var result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = _toConsumableArray(selfPath(nextNode)).concat(_toConsumableArray(pathFragment));\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\n\n\nfunction insertNode(_ref22) {\n  var treeData = _ref22.treeData,\n      targetDepth = _ref22.depth,\n      minimumTreeIndex = _ref22.minimumTreeIndex,\n      newNode = _ref22.newNode,\n      _ref22$getNodeKey = _ref22.getNodeKey,\n      getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,\n      _ref22$ignoreCollapse = _ref22.ignoreCollapsed,\n      ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,\n      _ref22$expandParent = _ref22.expandParent,\n      expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;\n\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({\n        node: newNode,\n        treeIndex: 0\n      })],\n      parentNode: null\n    };\n  }\n\n  var insertResult = addNodeAtDepthAndIndex({\n    targetDepth: targetDepth,\n    minimumTreeIndex: minimumTreeIndex,\n    newNode: newNode,\n    ignoreCollapsed: ignoreCollapsed,\n    expandParent: expandParent,\n    getNodeKey: getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.');\n  }\n\n  var treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex: treeIndex,\n    path: _toConsumableArray(insertResult.parentPath).concat([getNodeKey({\n      node: newNode,\n      treeIndex: treeIndex\n    })]),\n    parentNode: insertResult.parentNode\n  };\n}\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\n\n\nfunction getFlatDataFromTree(_ref23) {\n  var treeData = _ref23.treeData,\n      getNodeKey = _ref23.getNodeKey,\n      _ref23$ignoreCollapse = _ref23.ignoreCollapsed,\n      ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  var flattened = [];\n  walk({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(nodeInfo) {\n      flattened.push(nodeInfo);\n    }\n  });\n  return flattened;\n}\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\n\n\nfunction getTreeFromFlatData(_ref24) {\n  var flatData = _ref24.flatData,\n      _ref24$getKey = _ref24.getKey,\n      getKey = _ref24$getKey === void 0 ? function (node) {\n    return node.id;\n  } : _ref24$getKey,\n      _ref24$getParentKey = _ref24.getParentKey,\n      getParentKey = _ref24$getParentKey === void 0 ? function (node) {\n    return node.parentId;\n  } : _ref24$getParentKey,\n      _ref24$rootKey = _ref24.rootKey,\n      rootKey = _ref24$rootKey === void 0 ? '0' : _ref24$rootKey;\n\n  if (!flatData) {\n    return [];\n  }\n\n  var childrenToParents = {};\n  flatData.forEach(function (child) {\n    var parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  var trav = function trav(parent) {\n    var parentKey = getKey(parent);\n\n    if (parentKey in childrenToParents) {\n      return _objectSpread({}, parent, {\n        children: childrenToParents[parentKey].map(function (child) {\n          return trav(child);\n        })\n      });\n    }\n\n    return _objectSpread({}, parent);\n  };\n\n  return childrenToParents[rootKey].map(function (child) {\n    return trav(child);\n  });\n}\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\n\n\nfunction isDescendant(older, younger) {\n  return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n    return child === younger || isDescendant(child, younger);\n  });\n}\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\n\n\nfunction getDepth(node) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1;\n  }\n\n  return node.children.reduce(function (deepest, child) {\n    return Math.max(deepest, getDepth(child, depth + 1));\n  }, depth);\n}\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\n\n\nfunction find(_ref25) {\n  var getNodeKey = _ref25.getNodeKey,\n      treeData = _ref25.treeData,\n      searchQuery = _ref25.searchQuery,\n      searchMethod = _ref25.searchMethod,\n      searchFocusOffset = _ref25.searchFocusOffset,\n      _ref25$expandAllMatch = _ref25.expandAllMatchPaths,\n      expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,\n      _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,\n      expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;\n  var matchCount = 0;\n\n  var trav = function trav(_ref26) {\n    var _ref26$isPseudoRoot = _ref26.isPseudoRoot,\n        isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,\n        node = _ref26.node,\n        currentIndex = _ref26.currentIndex,\n        _ref26$path = _ref26.path,\n        path = _ref26$path === void 0 ? [] : _ref26$path;\n    var matches = [];\n    var isSelfMatch = false;\n    var hasFocusMatch = false; // The pseudo-root is not considered in the path\n\n    var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n      node: node,\n      treeIndex: currentIndex\n    })]);\n    var extraInfo = isPseudoRoot ? null : {\n      path: selfPath,\n      treeIndex: currentIndex\n    }; // Nodes with with children that aren't lazy\n\n    var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0; // Examine the current node to see if it is a match\n\n    if (!isPseudoRoot && searchMethod(_objectSpread({}, extraInfo, {\n      node: node,\n      searchQuery: searchQuery\n    }))) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      } // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n\n\n      matchCount += 1; // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n\n      isSelfMatch = true;\n    }\n\n    var childIndex = currentIndex;\n\n    var newNode = _objectSpread({}, node);\n\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(function (child) {\n        var mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = _toConsumableArray(matches).concat(_toConsumableArray(mapResult.matches));\n\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          } // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n\n\n          if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    } // Cannot assign a treeIndex to hidden nodes\n\n\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(function (match) {\n        return _objectSpread({}, match, {\n          treeIndex: null\n        });\n      });\n    } // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n\n\n    if (isSelfMatch) {\n      matches = [_objectSpread({}, extraInfo, {\n        node: newNode\n      })].concat(_toConsumableArray(matches));\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches: matches,\n      hasFocusMatch: hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  var result = trav({\n    node: {\n      children: treeData\n    },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\nvar NodeRendererDefault = /*#__PURE__*/function (_Component) {\n  _inherits(NodeRendererDefault, _Component);\n\n  function NodeRendererDefault() {\n    _classCallCheck(this, NodeRendererDefault);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NodeRendererDefault).apply(this, arguments));\n  }\n\n  _createClass(NodeRendererDefault, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          toggleChildrenVisibility = _this$props.toggleChildrenVisibility,\n          connectDragPreview = _this$props.connectDragPreview,\n          connectDragSource = _this$props.connectDragSource,\n          isDragging = _this$props.isDragging,\n          canDrop = _this$props.canDrop,\n          canDrag = _this$props.canDrag,\n          node = _this$props.node,\n          title = _this$props.title,\n          subtitle = _this$props.subtitle,\n          draggedNode = _this$props.draggedNode,\n          path = _this$props.path,\n          treeIndex = _this$props.treeIndex,\n          isSearchMatch = _this$props.isSearchMatch,\n          isSearchFocus = _this$props.isSearchFocus,\n          buttons = _this$props.buttons,\n          className = _this$props.className,\n          style = _this$props.style,\n          didDrop = _this$props.didDrop,\n          treeId = _this$props.treeId,\n          isOver = _this$props.isOver,\n          parentNode = _this$props.parentNode,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"scaffoldBlockPxWidth\", \"toggleChildrenVisibility\", \"connectDragPreview\", \"connectDragSource\", \"isDragging\", \"canDrop\", \"canDrag\", \"node\", \"title\", \"subtitle\", \"draggedNode\", \"path\", \"treeIndex\", \"isSearchMatch\", \"isSearchFocus\", \"buttons\", \"className\", \"style\", \"didDrop\", \"treeId\", \"isOver\", \"parentNode\", \"rowDirection\"]);\n\n      var nodeTitle = title || node.title;\n      var nodeSubtitle = subtitle || node.subtitle;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var handle;\n\n      if (canDrag) {\n        if (typeof node.children === 'function' && node.expanded) {\n          // Show a loading symbol on the handle when the children are expanded\n          //  and yet still defined by a function (a callback to fetch the children)\n          handle = React.createElement(\"div\", {\n            className: \"rst__loadingHandle\"\n          }, React.createElement(\"div\", {\n            className: \"rst__loadingCircle\"\n          }, _toConsumableArray(new Array(12)).map(function (_, index) {\n            return React.createElement(\"div\", {\n              // eslint-disable-next-line react/no-array-index-key\n              key: index,\n              className: classnames('rst__loadingCirclePoint', rowDirectionClass)\n            });\n          })));\n        } else {\n          // Show the handle used to initiate a drag-and-drop\n          handle = connectDragSource(React.createElement(\"div\", {\n            className: \"rst__moveHandle\"\n          }), {\n            dropEffect: 'copy'\n          });\n        }\n      }\n\n      var isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\n      var isLandingPadActive = !didDrop && isDragging;\n      var buttonStyle = {\n        left: -0.5 * scaffoldBlockPxWidth\n      };\n\n      if (rowDirection === 'rtl') {\n        buttonStyle = {\n          right: -0.5 * scaffoldBlockPxWidth\n        };\n      }\n\n      return React.createElement(\"div\", _extends({\n        style: {\n          height: '100%'\n        }\n      }, otherProps), toggleChildrenVisibility && node.children && (node.children.length > 0 || typeof node.children === 'function') && React.createElement(\"div\", null, React.createElement(\"button\", {\n        type: \"button\",\n        \"aria-label\": node.expanded ? 'Collapse' : 'Expand',\n        className: classnames(node.expanded ? 'rst__collapseButton' : 'rst__expandButton', rowDirectionClass),\n        style: buttonStyle,\n        onClick: function onClick() {\n          return toggleChildrenVisibility({\n            node: node,\n            path: path,\n            treeIndex: treeIndex\n          });\n        }\n      }), node.expanded && !isDragging && React.createElement(\"div\", {\n        style: {\n          width: scaffoldBlockPxWidth\n        },\n        className: classnames('rst__lineChildren', rowDirectionClass)\n      })), React.createElement(\"div\", {\n        className: classnames('rst__rowWrapper', rowDirectionClass)\n      }, connectDragPreview(React.createElement(\"div\", {\n        className: classnames('rst__row', isLandingPadActive && 'rst__rowLandingPad', isLandingPadActive && !canDrop && 'rst__rowCancelPad', isSearchMatch && 'rst__rowSearchMatch', isSearchFocus && 'rst__rowSearchFocus', rowDirectionClass, className),\n        style: _objectSpread({\n          opacity: isDraggedDescendant ? 0.5 : 1\n        }, style)\n      }, handle, React.createElement(\"div\", {\n        className: classnames('rst__rowContents', !canDrag && 'rst__rowContentsDragDisabled', rowDirectionClass)\n      }, React.createElement(\"div\", {\n        className: classnames('rst__rowLabel', rowDirectionClass)\n      }, React.createElement(\"span\", {\n        className: classnames('rst__rowTitle', node.subtitle && 'rst__rowTitleWithSubtitle')\n      }, typeof nodeTitle === 'function' ? nodeTitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeTitle), nodeSubtitle && React.createElement(\"span\", {\n        className: \"rst__rowSubtitle\"\n      }, typeof nodeSubtitle === 'function' ? nodeSubtitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeSubtitle)), React.createElement(\"div\", {\n        className: \"rst__rowToolbar\"\n      }, buttons.map(function (btn, index) {\n        return React.createElement(\"div\", {\n          key: index // eslint-disable-line react/no-array-index-key\n          ,\n          className: \"rst__toolbarButton\"\n        }, btn);\n      })))))));\n    }\n  }]);\n\n  return NodeRendererDefault;\n}(Component);\n\nNodeRendererDefault.defaultProps = {\n  isSearchMatch: false,\n  isSearchFocus: false,\n  canDrag: false,\n  toggleChildrenVisibility: null,\n  buttons: [],\n  className: '',\n  style: {},\n  parentNode: null,\n  draggedNode: null,\n  canDrop: false,\n  title: null,\n  subtitle: null,\n  rowDirection: 'ltr'\n};\nNodeRendererDefault.propTypes = {\n  node: PropTypes.shape({}).isRequired,\n  title: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  subtitle: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  isSearchMatch: PropTypes.bool,\n  isSearchFocus: PropTypes.bool,\n  canDrag: PropTypes.bool,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  toggleChildrenVisibility: PropTypes.func,\n  buttons: PropTypes.arrayOf(PropTypes.node),\n  className: PropTypes.string,\n  style: PropTypes.shape({}),\n  // Drag and drop API functions\n  // Drag source\n  connectDragPreview: PropTypes.func.isRequired,\n  connectDragSource: PropTypes.func.isRequired,\n  parentNode: PropTypes.shape({}),\n  // Needed for dndManager\n  isDragging: PropTypes.bool.isRequired,\n  didDrop: PropTypes.bool.isRequired,\n  draggedNode: PropTypes.shape({}),\n  // Drop target\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nvar TreePlaceholder = /*#__PURE__*/function (_Component) {\n  _inherits(TreePlaceholder, _Component);\n\n  function TreePlaceholder() {\n    _classCallCheck(this, TreePlaceholder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TreePlaceholder).apply(this, arguments));\n  }\n\n  _createClass(TreePlaceholder, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          connectDropTarget = _this$props.connectDropTarget,\n          treeId = _this$props.treeId,\n          drop = _this$props.drop,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"connectDropTarget\", \"treeId\", \"drop\"]);\n\n      return connectDropTarget(React.createElement(\"div\", null, Children.map(children, function (child) {\n        return cloneElement(child, _objectSpread({}, otherProps));\n      })));\n    }\n  }]);\n\n  return TreePlaceholder;\n}(Component);\n\nTreePlaceholder.defaultProps = {\n  canDrop: false,\n  draggedNode: null\n};\nTreePlaceholder.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  treeId: PropTypes.string.isRequired,\n  drop: PropTypes.func.isRequired\n};\n\nvar PlaceholderRendererDefault = function PlaceholderRendererDefault(_ref) {\n  var isOver = _ref.isOver,\n      canDrop = _ref.canDrop;\n  return React.createElement(\"div\", {\n    className: classnames('rst__placeholder', canDrop && 'rst__placeholderLandingPad', canDrop && !isOver && 'rst__placeholderCancelPad')\n  });\n};\n\nPlaceholderRendererDefault.defaultProps = {\n  isOver: false,\n  canDrop: false\n};\nPlaceholderRendererDefault.propTypes = {\n  isOver: PropTypes.bool,\n  canDrop: PropTypes.bool\n};\n\nvar memoize = function memoize(f) {\n  var savedArgsArray = [];\n  var savedKeysArray = [];\n  var savedResult = null;\n  return function (args) {\n    var keysArray = Object.keys(args).sort();\n    var argsArray = keysArray.map(function (key) {\n      return args[key];\n    }); // If the arguments for the last insert operation are different than this time,\n    // recalculate the result\n\n    if (argsArray.length !== savedArgsArray.length || argsArray.some(function (arg, index) {\n      return arg !== savedArgsArray[index];\n    }) || keysArray.some(function (key, index) {\n      return key !== savedKeysArray[index];\n    })) {\n      savedArgsArray = argsArray;\n      savedKeysArray = keysArray;\n      savedResult = f(args);\n    }\n\n    return savedResult;\n  };\n};\n\nvar memoizedInsertNode = memoize(insertNode);\nvar memoizedGetFlatDataFromTree = memoize(getFlatDataFromTree);\nvar memoizedGetDescendantCount = memoize(getDescendantCount);\n/* eslint-disable import/prefer-default-export */\n\nfunction slideRows(rows, fromIndex, toIndex) {\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n  var rowsWithoutMoved = _toConsumableArray(rows.slice(0, fromIndex)).concat(_toConsumableArray(rows.slice(fromIndex + count)));\n\n  return _toConsumableArray(rowsWithoutMoved.slice(0, toIndex)).concat(_toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n}\n\nfunction defaultGetNodeKey(_ref) {\n  var treeIndex = _ref.treeIndex;\n  return treeIndex;\n} // Cheap hack to get the text of a react object\n\n\nfunction getReactElementText(parent) {\n  if (typeof parent === 'string') {\n    return parent;\n  }\n\n  if (parent === null || _typeof(parent) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n    return '';\n  }\n\n  if (typeof parent.props.children === 'string') {\n    return parent.props.children;\n  }\n\n  return parent.props.children.map(function (child) {\n    return getReactElementText(child);\n  }).join('');\n} // Search for a query string inside a node property\n\n\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n  if (typeof node[key] === 'function') {\n    // Search within text after calling its function to generate the text\n    return String(node[key]({\n      node: node,\n      path: path,\n      treeIndex: treeIndex\n    })).indexOf(searchQuery) > -1;\n  }\n\n  if (_typeof(node[key]) === 'object') {\n    // Search within text inside react elements\n    return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n  } // Search within string\n\n\n  return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n}\n\nfunction defaultSearchMethod(_ref2) {\n  var node = _ref2.node,\n      path = _ref2.path,\n      treeIndex = _ref2.treeIndex,\n      searchQuery = _ref2.searchQuery;\n  return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n}\n\nvar DndManager = /*#__PURE__*/function () {\n  function DndManager(treeRef) {\n    _classCallCheck(this, DndManager);\n\n    this.treeRef = treeRef;\n  }\n\n  _createClass(DndManager, [{\n    key: \"getTargetDepth\",\n    value: function getTargetDepth(dropTargetProps, monitor, component) {\n      var dropTargetDepth = 0;\n      var rowAbove = dropTargetProps.getPrevRow();\n\n      if (rowAbove) {\n        var path = rowAbove.path;\n        var aboveNodeCannotHaveChildren = !this.treeRef.canNodeHaveChildren(rowAbove.node);\n\n        if (aboveNodeCannotHaveChildren) {\n          path = path.slice(0, path.length - 1);\n        } // Limit the length of the path to the deepest possible\n\n\n        dropTargetDepth = Math.min(path.length, dropTargetProps.path.length);\n      }\n\n      var blocksOffset;\n      var dragSourceInitialDepth = (monitor.getItem().path || []).length; // When adding node from external source\n\n      if (monitor.getItem().treeId !== this.treeId) {\n        // Ignore the tree depth of the source, if it had any to begin with\n        dragSourceInitialDepth = 0;\n\n        if (component) {\n          var relativePosition = findDOMNode(component).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node\n\n          var leftShift = monitor.getSourceClientOffset().x - relativePosition.left;\n          blocksOffset = Math.round(leftShift / dropTargetProps.scaffoldBlockPxWidth);\n        } else {\n          blocksOffset = dropTargetProps.path.length;\n        }\n      } else {\n        // handle row direction support\n        var direction = dropTargetProps.rowDirection === 'rtl' ? -1 : 1;\n        blocksOffset = Math.round(direction * monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n      }\n\n      var targetDepth = Math.min(dropTargetDepth, Math.max(0, dragSourceInitialDepth + blocksOffset - 1)); // If a maxDepth is defined, constrain the target depth\n\n      if (typeof this.maxDepth !== 'undefined' && this.maxDepth !== null) {\n        var draggedNode = monitor.getItem().node;\n        var draggedChildDepth = getDepth(draggedNode);\n        targetDepth = Math.max(0, Math.min(targetDepth, this.maxDepth - draggedChildDepth - 1));\n      }\n\n      return targetDepth;\n    }\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dropTargetProps, monitor) {\n      if (!monitor.isOver()) {\n        return false;\n      }\n\n      var rowAbove = dropTargetProps.getPrevRow();\n      var abovePath = rowAbove ? rowAbove.path : [];\n      var aboveNode = rowAbove ? rowAbove.node : {};\n      var targetDepth = this.getTargetDepth(dropTargetProps, monitor, null); // Cannot drop if we're adding to the children of the row above and\n      //  the row above is a function\n\n      if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\n        return false;\n      }\n\n      if (typeof this.customCanDrop === 'function') {\n        var _monitor$getItem = monitor.getItem(),\n            node = _monitor$getItem.node;\n\n        var addedResult = memoizedInsertNode({\n          treeData: this.treeData,\n          newNode: node,\n          depth: targetDepth,\n          getNodeKey: this.getNodeKey,\n          minimumTreeIndex: dropTargetProps.listIndex,\n          expandParent: true\n        });\n        return this.customCanDrop({\n          node: node,\n          prevPath: monitor.getItem().path,\n          prevParent: monitor.getItem().parentNode,\n          prevTreeIndex: monitor.getItem().treeIndex,\n          // Equals -1 when dragged from external tree\n          nextPath: addedResult.path,\n          nextParent: addedResult.parentNode,\n          nextTreeIndex: addedResult.treeIndex\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"wrapSource\",\n    value: function wrapSource(el) {\n      var _this = this;\n\n      var nodeDragSource = {\n        beginDrag: function beginDrag(props) {\n          _this.startDrag(props);\n\n          return {\n            node: props.node,\n            parentNode: props.parentNode,\n            path: props.path,\n            treeIndex: props.treeIndex,\n            treeId: props.treeId\n          };\n        },\n        endDrag: function endDrag(props, monitor) {\n          _this.endDrag(monitor.getDropResult());\n        },\n        isDragging: function isDragging(props, monitor) {\n          var dropTargetNode = monitor.getItem().node;\n          var draggedNode = props.node;\n          return draggedNode === dropTargetNode;\n        }\n      };\n\n      function nodeDragSourcePropInjection(connect, monitor) {\n        return {\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n          didDrop: monitor.didDrop()\n        };\n      }\n\n      return DragSource(this.dndType, nodeDragSource, nodeDragSourcePropInjection)(el);\n    }\n  }, {\n    key: \"wrapTarget\",\n    value: function wrapTarget(el) {\n      var _this2 = this;\n\n      var nodeDropTarget = {\n        drop: function drop(dropTargetProps, monitor, component) {\n          var result = {\n            node: monitor.getItem().node,\n            path: monitor.getItem().path,\n            treeIndex: monitor.getItem().treeIndex,\n            treeId: _this2.treeId,\n            minimumTreeIndex: dropTargetProps.treeIndex,\n            depth: _this2.getTargetDepth(dropTargetProps, monitor, component)\n          };\n\n          _this2.drop(result);\n\n          return result;\n        },\n        hover: function hover(dropTargetProps, monitor, component) {\n          var targetDepth = _this2.getTargetDepth(dropTargetProps, monitor, component);\n\n          var draggedNode = monitor.getItem().node;\n          var needsRedraw = // Redraw if hovered above different nodes\n          dropTargetProps.node !== draggedNode || // Or hovered above the same node but at a different depth\n          targetDepth !== dropTargetProps.path.length - 1;\n\n          if (!needsRedraw) {\n            return;\n          } // throttle `dragHover` work to available animation frames\n\n\n          cancelAnimationFrame(_this2.rafId);\n          _this2.rafId = requestAnimationFrame(function () {\n            _this2.dragHover({\n              node: draggedNode,\n              path: monitor.getItem().path,\n              minimumTreeIndex: dropTargetProps.listIndex,\n              depth: targetDepth\n            });\n          });\n        },\n        canDrop: this.canDrop.bind(this)\n      };\n\n      function nodeDropTargetPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, nodeDropTarget, nodeDropTargetPropInjection)(el);\n    }\n  }, {\n    key: \"wrapPlaceholder\",\n    value: function wrapPlaceholder(el) {\n      var _this3 = this;\n\n      var placeholderDropTarget = {\n        drop: function drop(dropTargetProps, monitor) {\n          var _monitor$getItem2 = monitor.getItem(),\n              node = _monitor$getItem2.node,\n              path = _monitor$getItem2.path,\n              treeIndex = _monitor$getItem2.treeIndex;\n\n          var result = {\n            node: node,\n            path: path,\n            treeIndex: treeIndex,\n            treeId: _this3.treeId,\n            minimumTreeIndex: 0,\n            depth: 0\n          };\n\n          _this3.drop(result);\n\n          return result;\n        }\n      };\n\n      function placeholderPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, placeholderDropTarget, placeholderPropInjection)(el);\n    }\n  }, {\n    key: \"startDrag\",\n    get: function get() {\n      return this.treeRef.startDrag;\n    }\n  }, {\n    key: \"dragHover\",\n    get: function get() {\n      return this.treeRef.dragHover;\n    }\n  }, {\n    key: \"endDrag\",\n    get: function get() {\n      return this.treeRef.endDrag;\n    }\n  }, {\n    key: \"drop\",\n    get: function get() {\n      return this.treeRef.drop;\n    }\n  }, {\n    key: \"treeId\",\n    get: function get() {\n      return this.treeRef.treeId;\n    }\n  }, {\n    key: \"dndType\",\n    get: function get() {\n      return this.treeRef.dndType;\n    }\n  }, {\n    key: \"treeData\",\n    get: function get() {\n      return this.treeRef.state.draggingTreeData || this.treeRef.props.treeData;\n    }\n  }, {\n    key: \"getNodeKey\",\n    get: function get() {\n      return this.treeRef.props.getNodeKey;\n    }\n  }, {\n    key: \"customCanDrop\",\n    get: function get() {\n      return this.treeRef.props.canDrop;\n    }\n  }, {\n    key: \"maxDepth\",\n    get: function get() {\n      return this.treeRef.props.maxDepth;\n    }\n  }]);\n\n  return DndManager;\n}();\n\nvar treeIdCounter = 1;\n\nvar mergeTheme = function mergeTheme(props) {\n  var merged = _objectSpread({}, props, {\n    style: _objectSpread({}, props.theme.style, props.style),\n    innerStyle: _objectSpread({}, props.theme.innerStyle, props.innerStyle),\n    reactVirtualizedListProps: _objectSpread({}, props.theme.reactVirtualizedListProps, props.reactVirtualizedListProps)\n  });\n\n  var overridableDefaults = {\n    nodeContentRenderer: NodeRendererDefault,\n    placeholderRenderer: PlaceholderRendererDefault,\n    rowHeight: 62,\n    scaffoldBlockPxWidth: 44,\n    slideRegionSize: 100,\n    treeNodeRenderer: TreeNode\n  };\n  Object.keys(overridableDefaults).forEach(function (propKey) {\n    // If prop has been specified, do not change it\n    // If prop is specified in theme, use the theme setting\n    // If all else fails, fall back to the default\n    if (props[propKey] === null) {\n      merged[propKey] = typeof props.theme[propKey] !== 'undefined' ? props.theme[propKey] : overridableDefaults[propKey];\n    }\n  });\n  return merged;\n};\n\nvar ReactSortableTree = /*#__PURE__*/function (_Component) {\n  _inherits(ReactSortableTree, _Component);\n\n  function ReactSortableTree(props) {\n    var _this;\n\n    _classCallCheck(this, ReactSortableTree);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactSortableTree).call(this, props));\n\n    var _mergeTheme = mergeTheme(props),\n        dndType = _mergeTheme.dndType,\n        nodeContentRenderer = _mergeTheme.nodeContentRenderer,\n        treeNodeRenderer = _mergeTheme.treeNodeRenderer,\n        isVirtualized = _mergeTheme.isVirtualized,\n        slideRegionSize = _mergeTheme.slideRegionSize;\n\n    _this.dndManager = new DndManager(_assertThisInitialized(_assertThisInitialized(_this))); // Wrapping classes for use with react-dnd\n\n    _this.treeId = \"rst__\".concat(treeIdCounter);\n    treeIdCounter += 1;\n    _this.dndType = dndType || _this.treeId;\n    _this.nodeContentRenderer = _this.dndManager.wrapSource(nodeContentRenderer);\n    _this.treePlaceholderRenderer = _this.dndManager.wrapPlaceholder(TreePlaceholder);\n    _this.treeNodeRenderer = _this.dndManager.wrapTarget(treeNodeRenderer); // Prepare scroll-on-drag options for this list\n\n    if (isVirtualized) {\n      _this.scrollZoneVirtualList = (createScrollingComponent || withScrolling)(List);\n      _this.vStrength = createVerticalStrength(slideRegionSize);\n      _this.hStrength = createHorizontalStrength(slideRegionSize);\n    }\n\n    _this.state = {\n      draggingTreeData: null,\n      draggedNode: null,\n      draggedMinimumTreeIndex: null,\n      draggedDepth: null,\n      searchMatches: [],\n      searchFocusTreeIndex: null,\n      dragging: false,\n      // props that need to be used in gDSFP or static functions will be stored here\n      instanceProps: {\n        treeData: [],\n        ignoreOneTreeUpdate: false,\n        searchQuery: null,\n        searchFocusOffset: null\n      }\n    };\n    _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.moveNode = _this.moveNode.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.startDrag = _this.startDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dragHover = _this.dragHover.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.endDrag = _this.endDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.drop = _this.drop.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleDndMonitorChange = _this.handleDndMonitorChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(ReactSortableTree, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      ReactSortableTree.loadLazyChildren(this.props, this.state);\n      var stateUpdate = ReactSortableTree.search(this.props, this.state, true, true, false);\n      this.setState(stateUpdate); // Hook into react-dnd state changes to detect when the drag ends\n      // TODO: This is very brittle, so it needs to be replaced if react-dnd\n      // offers a more official way to detect when a drag ends\n\n      this.clearMonitorSubscription = this.props.dragDropManager.getMonitor().subscribeToStateChange(this.handleDndMonitorChange);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    // listen to dragging\n    value: function componentDidUpdate(prevProps, prevState) {\n      // if it is not the same then call the onDragStateChanged\n      if (this.state.dragging !== prevState.dragging) {\n        if (this.props.onDragStateChanged) {\n          this.props.onDragStateChanged({\n            isDragging: this.state.dragging,\n            draggedNode: this.state.draggedNode\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearMonitorSubscription();\n    }\n  }, {\n    key: \"getRows\",\n    value: function getRows(treeData) {\n      return memoizedGetFlatDataFromTree({\n        ignoreCollapsed: true,\n        getNodeKey: this.props.getNodeKey,\n        treeData: treeData\n      });\n    }\n  }, {\n    key: \"handleDndMonitorChange\",\n    value: function handleDndMonitorChange() {\n      var monitor = this.props.dragDropManager.getMonitor(); // If the drag ends and the tree is still in a mid-drag state,\n      // it means that the drag was canceled or the dragSource dropped\n      // elsewhere, and we should reset the state of this tree\n\n      if (!monitor.isDragging() && this.state.draggingTreeData) {\n        this.endDrag();\n      }\n    }\n  }, {\n    key: \"toggleChildrenVisibility\",\n    value: function toggleChildrenVisibility(_ref) {\n      var targetNode = _ref.node,\n          path = _ref.path;\n      var instanceProps = this.state.instanceProps;\n      var treeData = changeNodeAtPath({\n        treeData: instanceProps.treeData,\n        path: path,\n        newNode: function newNode(_ref2) {\n          var node = _ref2.node;\n          return _objectSpread({}, node, {\n            expanded: !node.expanded\n          });\n        },\n        getNodeKey: this.props.getNodeKey\n      });\n      this.props.onChange(treeData);\n      this.props.onVisibilityToggle({\n        treeData: treeData,\n        node: targetNode,\n        expanded: !targetNode.expanded,\n        path: path\n      });\n    }\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(_ref3) {\n      var node = _ref3.node,\n          prevPath = _ref3.path,\n          prevTreeIndex = _ref3.treeIndex,\n          depth = _ref3.depth,\n          minimumTreeIndex = _ref3.minimumTreeIndex;\n\n      var _insertNode = insertNode({\n        treeData: this.state.draggingTreeData,\n        newNode: node,\n        depth: depth,\n        minimumTreeIndex: minimumTreeIndex,\n        expandParent: true,\n        getNodeKey: this.props.getNodeKey\n      }),\n          treeData = _insertNode.treeData,\n          treeIndex = _insertNode.treeIndex,\n          path = _insertNode.path,\n          nextParentNode = _insertNode.parentNode;\n\n      this.props.onChange(treeData);\n      this.props.onMoveNode({\n        treeData: treeData,\n        node: node,\n        treeIndex: treeIndex,\n        path: path,\n        nextPath: path,\n        nextTreeIndex: treeIndex,\n        prevPath: prevPath,\n        prevTreeIndex: prevTreeIndex,\n        nextParentNode: nextParentNode\n      });\n    } // returns the new state after search\n\n  }, {\n    key: \"startDrag\",\n    value: function startDrag(_ref4) {\n      var _this2 = this;\n\n      var path = _ref4.path;\n      this.setState(function (prevState) {\n        var _removeNode = removeNode({\n          treeData: prevState.instanceProps.treeData,\n          path: path,\n          getNodeKey: _this2.props.getNodeKey\n        }),\n            draggingTreeData = _removeNode.treeData,\n            draggedNode = _removeNode.node,\n            draggedMinimumTreeIndex = _removeNode.treeIndex;\n\n        return {\n          draggingTreeData: draggingTreeData,\n          draggedNode: draggedNode,\n          draggedDepth: path.length - 1,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"dragHover\",\n    value: function dragHover(_ref5) {\n      var _this3 = this;\n\n      var draggedNode = _ref5.node,\n          draggedDepth = _ref5.depth,\n          draggedMinimumTreeIndex = _ref5.minimumTreeIndex; // Ignore this hover if it is at the same position as the last hover\n\n      if (this.state.draggedDepth === draggedDepth && this.state.draggedMinimumTreeIndex === draggedMinimumTreeIndex) {\n        return;\n      }\n\n      this.setState(function (_ref6) {\n        var draggingTreeData = _ref6.draggingTreeData,\n            instanceProps = _ref6.instanceProps; // Fall back to the tree data if something is being dragged in from\n        //  an external element\n\n        var newDraggingTreeData = draggingTreeData || instanceProps.treeData;\n        var addedResult = memoizedInsertNode({\n          treeData: newDraggingTreeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: _this3.props.getNodeKey\n        });\n\n        var rows = _this3.getRows(addedResult.treeData);\n\n        var expandedParentPath = rows[addedResult.treeIndex].path;\n        return {\n          draggedNode: draggedNode,\n          draggedDepth: draggedDepth,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          draggingTreeData: changeNodeAtPath({\n            treeData: newDraggingTreeData,\n            path: expandedParentPath.slice(0, -1),\n            newNode: function newNode(_ref7) {\n              var node = _ref7.node;\n              return _objectSpread({}, node, {\n                expanded: true\n              });\n            },\n            getNodeKey: _this3.props.getNodeKey\n          }),\n          // reset the scroll focus so it doesn't jump back\n          // to a search result while dragging\n          searchFocusTreeIndex: null,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"endDrag\",\n    value: function endDrag(dropResult) {\n      var _this4 = this;\n\n      var instanceProps = this.state.instanceProps;\n\n      var resetTree = function resetTree() {\n        return _this4.setState({\n          draggingTreeData: null,\n          draggedNode: null,\n          draggedMinimumTreeIndex: null,\n          draggedDepth: null,\n          dragging: false\n        });\n      }; // Drop was cancelled\n\n\n      if (!dropResult) {\n        resetTree();\n      } else if (dropResult.treeId !== this.treeId) {\n        // The node was dropped in an external drop target or tree\n        var node = dropResult.node,\n            path = dropResult.path,\n            treeIndex = dropResult.treeIndex;\n        var shouldCopy = this.props.shouldCopyOnOutsideDrop;\n\n        if (typeof shouldCopy === 'function') {\n          shouldCopy = shouldCopy({\n            node: node,\n            prevTreeIndex: treeIndex,\n            prevPath: path\n          });\n        }\n\n        var treeData = this.state.draggingTreeData || instanceProps.treeData; // If copying is enabled, a drop outside leaves behind a copy in the\n        //  source tree\n\n        if (shouldCopy) {\n          treeData = changeNodeAtPath({\n            treeData: instanceProps.treeData,\n            // use treeData unaltered by the drag operation\n            path: path,\n            newNode: function newNode(_ref8) {\n              var copyNode = _ref8.node;\n              return _objectSpread({}, copyNode);\n            },\n            // create a shallow copy of the node\n            getNodeKey: this.props.getNodeKey\n          });\n        }\n\n        this.props.onChange(treeData);\n        this.props.onMoveNode({\n          treeData: treeData,\n          node: node,\n          treeIndex: null,\n          path: null,\n          nextPath: null,\n          nextTreeIndex: null,\n          prevPath: path,\n          prevTreeIndex: treeIndex\n        });\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(dropResult) {\n      this.moveNode(dropResult);\n    }\n  }, {\n    key: \"canNodeHaveChildren\",\n    value: function canNodeHaveChildren(node) {\n      var canNodeHaveChildren = this.props.canNodeHaveChildren;\n\n      if (canNodeHaveChildren) {\n        return canNodeHaveChildren(node);\n      }\n\n      return true;\n    } // Load any children in the tree that are given by a function\n    // calls the onChange callback on the new treeData\n\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(row, _ref9) {\n      var listIndex = _ref9.listIndex,\n          style = _ref9.style,\n          getPrevRow = _ref9.getPrevRow,\n          matchKeys = _ref9.matchKeys,\n          swapFrom = _ref9.swapFrom,\n          swapDepth = _ref9.swapDepth,\n          swapLength = _ref9.swapLength;\n      var node = row.node,\n          parentNode = row.parentNode,\n          path = row.path,\n          lowerSiblingCounts = row.lowerSiblingCounts,\n          treeIndex = row.treeIndex;\n\n      var _mergeTheme2 = mergeTheme(this.props),\n          canDrag = _mergeTheme2.canDrag,\n          generateNodeProps = _mergeTheme2.generateNodeProps,\n          scaffoldBlockPxWidth = _mergeTheme2.scaffoldBlockPxWidth,\n          searchFocusOffset = _mergeTheme2.searchFocusOffset,\n          rowDirection = _mergeTheme2.rowDirection;\n\n      var TreeNodeRenderer = this.treeNodeRenderer;\n      var NodeContentRenderer = this.nodeContentRenderer;\n      var nodeKey = path[path.length - 1];\n      var isSearchMatch = (nodeKey in matchKeys);\n      var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\n      var callbackParams = {\n        node: node,\n        parentNode: parentNode,\n        path: path,\n        lowerSiblingCounts: lowerSiblingCounts,\n        treeIndex: treeIndex,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus\n      };\n      var nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\n      var rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\n      var sharedProps = {\n        treeIndex: treeIndex,\n        scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n        node: node,\n        path: path,\n        treeId: this.treeId,\n        rowDirection: rowDirection\n      };\n      return React.createElement(TreeNodeRenderer, _extends({\n        style: style,\n        key: nodeKey,\n        listIndex: listIndex,\n        getPrevRow: getPrevRow,\n        lowerSiblingCounts: lowerSiblingCounts,\n        swapFrom: swapFrom,\n        swapLength: swapLength,\n        swapDepth: swapDepth\n      }, sharedProps), React.createElement(NodeContentRenderer, _extends({\n        parentNode: parentNode,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus,\n        canDrag: rowCanDrag,\n        toggleChildrenVisibility: this.toggleChildrenVisibility\n      }, sharedProps, nodeProps)));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _mergeTheme3 = mergeTheme(this.props),\n          dragDropManager = _mergeTheme3.dragDropManager,\n          style = _mergeTheme3.style,\n          className = _mergeTheme3.className,\n          innerStyle = _mergeTheme3.innerStyle,\n          rowHeight = _mergeTheme3.rowHeight,\n          isVirtualized = _mergeTheme3.isVirtualized,\n          placeholderRenderer = _mergeTheme3.placeholderRenderer,\n          reactVirtualizedListProps = _mergeTheme3.reactVirtualizedListProps,\n          getNodeKey = _mergeTheme3.getNodeKey,\n          rowDirection = _mergeTheme3.rowDirection;\n\n      var _this$state = this.state,\n          searchMatches = _this$state.searchMatches,\n          searchFocusTreeIndex = _this$state.searchFocusTreeIndex,\n          draggedNode = _this$state.draggedNode,\n          draggedDepth = _this$state.draggedDepth,\n          draggedMinimumTreeIndex = _this$state.draggedMinimumTreeIndex,\n          instanceProps = _this$state.instanceProps;\n      var treeData = this.state.draggingTreeData || instanceProps.treeData;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var rows;\n      var swapFrom = null;\n      var swapLength = null;\n\n      if (draggedNode && draggedMinimumTreeIndex !== null) {\n        var addedResult = memoizedInsertNode({\n          treeData: treeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: getNodeKey\n        });\n        var swapTo = draggedMinimumTreeIndex;\n        swapFrom = addedResult.treeIndex;\n        swapLength = 1 + memoizedGetDescendantCount({\n          node: draggedNode\n        });\n        rows = slideRows(this.getRows(addedResult.treeData), swapFrom, swapTo, swapLength);\n      } else {\n        rows = this.getRows(treeData);\n      } // Get indices for rows that match the search conditions\n\n\n      var matchKeys = {};\n      searchMatches.forEach(function (_ref10, i) {\n        var path = _ref10.path;\n        matchKeys[path[path.length - 1]] = i;\n      }); // Seek to the focused search result if there is one specified\n\n      var scrollToInfo = searchFocusTreeIndex !== null ? {\n        scrollToIndex: searchFocusTreeIndex\n      } : {};\n      var containerStyle = style;\n      var list;\n\n      if (rows.length < 1) {\n        var Placeholder = this.treePlaceholderRenderer;\n        var PlaceholderContent = placeholderRenderer;\n        list = React.createElement(Placeholder, {\n          treeId: this.treeId,\n          drop: this.drop\n        }, React.createElement(PlaceholderContent, null));\n      } else if (isVirtualized) {\n        containerStyle = _objectSpread({\n          height: '100%'\n        }, containerStyle);\n        var ScrollZoneVirtualList = this.scrollZoneVirtualList; // Render list with react-virtualized\n\n        list = React.createElement(AutoSizer, null, function (_ref11) {\n          var height = _ref11.height,\n              width = _ref11.width;\n          return React.createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {\n            dragDropManager: dragDropManager,\n            verticalStrength: _this5.vStrength,\n            horizontalStrength: _this5.hStrength,\n            speed: 30,\n            scrollToAlignment: \"start\",\n            className: \"rst__virtualScrollOverride\",\n            width: width,\n            onScroll: function onScroll(_ref12) {\n              var scrollTop = _ref12.scrollTop;\n              _this5.scrollTop = scrollTop;\n            },\n            height: height,\n            style: innerStyle,\n            rowCount: rows.length,\n            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,\n            rowHeight: typeof rowHeight !== 'function' ? rowHeight : function (_ref13) {\n              var index = _ref13.index;\n              return rowHeight({\n                index: index,\n                treeIndex: index,\n                node: rows[index].node,\n                path: rows[index].path\n              });\n            },\n            rowRenderer: function rowRenderer(_ref14) {\n              var index = _ref14.index,\n                  rowStyle = _ref14.style;\n              return _this5.renderRow(rows[index], {\n                listIndex: index,\n                style: rowStyle,\n                getPrevRow: function getPrevRow() {\n                  return rows[index - 1] || null;\n                },\n                matchKeys: matchKeys,\n                swapFrom: swapFrom,\n                swapDepth: draggedDepth,\n                swapLength: swapLength\n              });\n            }\n          }, reactVirtualizedListProps));\n        });\n      } else {\n        // Render list without react-virtualized\n        list = rows.map(function (row, index) {\n          return _this5.renderRow(row, {\n            listIndex: index,\n            style: {\n              height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({\n                index: index,\n                treeIndex: index,\n                node: row.node,\n                path: row.path\n              })\n            },\n            getPrevRow: function getPrevRow() {\n              return rows[index - 1] || null;\n            },\n            matchKeys: matchKeys,\n            swapFrom: swapFrom,\n            swapDepth: draggedDepth,\n            swapLength: swapLength\n          });\n        });\n      }\n\n      return React.createElement(\"div\", {\n        className: classnames('rst__tree', className, rowDirectionClass),\n        style: containerStyle\n      }, list);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var instanceProps = prevState.instanceProps;\n      var newState = {};\n      var isTreeDataEqual = isEqual(instanceProps.treeData, nextProps.treeData); // make sure we have the most recent version of treeData\n\n      instanceProps.treeData = nextProps.treeData;\n\n      if (!isTreeDataEqual) {\n        if (instanceProps.ignoreOneTreeUpdate) {\n          instanceProps.ignoreOneTreeUpdate = false;\n        } else {\n          newState.searchFocusTreeIndex = null;\n          ReactSortableTree.loadLazyChildren(nextProps, prevState);\n          Object.assign(newState, ReactSortableTree.search(nextProps, prevState, false, false, false));\n        }\n\n        newState.draggingTreeData = null;\n        newState.draggedNode = null;\n        newState.draggedMinimumTreeIndex = null;\n        newState.draggedDepth = null;\n        newState.dragging = false;\n      } else if (!isEqual(instanceProps.searchQuery, nextProps.searchQuery)) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, false));\n      } else if (instanceProps.searchFocusOffset !== nextProps.searchFocusOffset) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, true));\n      }\n\n      instanceProps.searchQuery = nextProps.searchQuery;\n      instanceProps.searchFocusOffset = nextProps.searchFocusOffset;\n      newState.instanceProps = instanceProps;\n      return newState;\n    }\n  }, {\n    key: \"search\",\n    value: function search(props, state, seekIndex, expand, singleSearch) {\n      var onChange = props.onChange,\n          getNodeKey = props.getNodeKey,\n          searchFinishCallback = props.searchFinishCallback,\n          searchQuery = props.searchQuery,\n          searchMethod = props.searchMethod,\n          searchFocusOffset = props.searchFocusOffset,\n          onlyExpandSearchedNodes = props.onlyExpandSearchedNodes;\n      var instanceProps = state.instanceProps; // Skip search if no conditions are specified\n\n      if (!searchQuery && !searchMethod) {\n        if (searchFinishCallback) {\n          searchFinishCallback([]);\n        }\n\n        return {\n          searchMatches: []\n        };\n      }\n\n      var newState = {}; // if onlyExpandSearchedNodes collapse the tree and search\n\n      var _find = find({\n        getNodeKey: getNodeKey,\n        treeData: onlyExpandSearchedNodes ? toggleExpandedForAll({\n          treeData: instanceProps.treeData,\n          expanded: false\n        }) : instanceProps.treeData,\n        searchQuery: searchQuery,\n        searchMethod: searchMethod || defaultSearchMethod,\n        searchFocusOffset: searchFocusOffset,\n        expandAllMatchPaths: expand && !singleSearch,\n        expandFocusMatchPaths: !!expand\n      }),\n          expandedTreeData = _find.treeData,\n          searchMatches = _find.matches; // Update the tree with data leaving all paths leading to matching nodes open\n\n\n      if (expand) {\n        newState.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\n        onChange(expandedTreeData);\n      }\n\n      if (searchFinishCallback) {\n        searchFinishCallback(searchMatches);\n      }\n\n      var searchFocusTreeIndex = null;\n\n      if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n        searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n      }\n\n      newState.searchMatches = searchMatches;\n      newState.searchFocusTreeIndex = searchFocusTreeIndex;\n      return newState;\n    }\n  }, {\n    key: \"loadLazyChildren\",\n    value: function loadLazyChildren(props, state) {\n      var instanceProps = state.instanceProps;\n      walk({\n        treeData: instanceProps.treeData,\n        getNodeKey: props.getNodeKey,\n        callback: function callback(_ref15) {\n          var node = _ref15.node,\n              path = _ref15.path,\n              lowerSiblingCounts = _ref15.lowerSiblingCounts,\n              treeIndex = _ref15.treeIndex; // If the node has children defined by a function, and is either expanded\n          //  or set to load even before expansion, run the function.\n\n          if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n            // Call the children fetching function\n            node.children({\n              node: node,\n              path: path,\n              lowerSiblingCounts: lowerSiblingCounts,\n              treeIndex: treeIndex,\n              // Provide a helper to append the new data when it is received\n              done: function done(childrenArray) {\n                return props.onChange(changeNodeAtPath({\n                  treeData: instanceProps.treeData,\n                  path: path,\n                  newNode: function newNode(_ref16) {\n                    var oldNode = _ref16.node;\n                    return (// Only replace the old node if it's the one we set off to find children\n                      //  for in the first place\n                      oldNode === node ? _objectSpread({}, oldNode, {\n                        children: childrenArray\n                      }) : oldNode\n                    );\n                  },\n                  getNodeKey: props.getNodeKey\n                }));\n              }\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReactSortableTree;\n}(Component);\n\nReactSortableTree.propTypes = {\n  dragDropManager: PropTypes.shape({\n    getMonitor: PropTypes.func\n  }).isRequired,\n  // Tree data in the following format:\n  // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n  // `title` is the primary label for the node\n  // `subtitle` is a secondary label for the node\n  // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n  // `children` is an array of child nodes belonging to the node.\n  treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\n  // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n  style: PropTypes.shape({}),\n  // Class name for the container wrapping the tree\n  className: PropTypes.string,\n  // Style applied to the inner, scrollable container (for padding, etc.)\n  innerStyle: PropTypes.shape({}),\n  // Used by react-virtualized\n  // Either a fixed row height (number) or a function that returns the\n  // height of a row given its index: `({ index: number }): number`\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  // Size in px of the region near the edges that initiates scrolling on dragover\n  slideRegionSize: PropTypes.number,\n  // Custom properties to hand to the react-virtualized list\n  // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n  reactVirtualizedListProps: PropTypes.shape({}),\n  // The width of the blocks containing the lines representing the structure of the tree.\n  scaffoldBlockPxWidth: PropTypes.number,\n  // Maximum depth nodes can be inserted at. Defaults to infinite.\n  maxDepth: PropTypes.number,\n  // The method used to search nodes.\n  // Defaults to a function that uses the `searchQuery` string to search for nodes with\n  // matching `title` or `subtitle` values.\n  // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n  searchMethod: PropTypes.func,\n  // Used by the `searchMethod` to highlight and scroll to matched nodes.\n  // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n  searchQuery: PropTypes.any,\n  // eslint-disable-line react/forbid-prop-types\n  // Outline the <`searchFocusOffset`>th node and scroll to it.\n  searchFocusOffset: PropTypes.number,\n  // Get the nodes that match the search criteria. Used for counting total matches, etc.\n  searchFinishCallback: PropTypes.func,\n  // Generate an object with additional props to be passed to the node renderer.\n  // Use this for adding buttons via the `buttons` key,\n  // or additional `style` / `className` settings.\n  generateNodeProps: PropTypes.func,\n  // Set to false to disable virtualization.\n  // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\n  isVirtualized: PropTypes.bool,\n  treeNodeRenderer: PropTypes.func,\n  // Override the default component for rendering nodes (but keep the scaffolding generator)\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n  nodeContentRenderer: PropTypes.func,\n  // Override the default component for rendering an empty tree\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `placeholder-renderer-default.js` to use as a base,\n  // and customize as needed.\n  placeholderRenderer: PropTypes.func,\n  theme: PropTypes.shape({\n    style: PropTypes.shape({}),\n    innerStyle: PropTypes.shape({}),\n    reactVirtualizedListProps: PropTypes.shape({}),\n    scaffoldBlockPxWidth: PropTypes.number,\n    slideRegionSize: PropTypes.number,\n    rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    treeNodeRenderer: PropTypes.func,\n    nodeContentRenderer: PropTypes.func,\n    placeholderRenderer: PropTypes.func\n  }),\n  // Determine the unique key used to identify each node and\n  // generate the `path` array passed in callbacks.\n  // By default, returns the index in the tree (omitting hidden nodes).\n  getNodeKey: PropTypes.func,\n  // Called whenever tree data changed.\n  // Just like with React input elements, you have to update your\n  // own component's data to see the changes reflected.\n  onChange: PropTypes.func.isRequired,\n  // Called after node move operation.\n  onMoveNode: PropTypes.func,\n  // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\n  canDrag: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Determine whether a node can be dropped based on its path and parents'.\n  canDrop: PropTypes.func,\n  // Determine whether a node can have children\n  canNodeHaveChildren: PropTypes.func,\n  // When true, or a callback returning true, dropping nodes to react-dnd\n  // drop targets outside of this tree will not remove them from this tree\n  shouldCopyOnOutsideDrop: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Called after children nodes collapsed or expanded.\n  onVisibilityToggle: PropTypes.func,\n  dndType: PropTypes.string,\n  // Called to track between dropped and dragging\n  onDragStateChanged: PropTypes.func,\n  // Specify that nodes that do not match search will be collapsed\n  onlyExpandSearchedNodes: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\nReactSortableTree.defaultProps = {\n  canDrag: true,\n  canDrop: null,\n  canNodeHaveChildren: function canNodeHaveChildren() {\n    return true;\n  },\n  className: '',\n  dndType: null,\n  generateNodeProps: null,\n  getNodeKey: defaultGetNodeKey,\n  innerStyle: {},\n  isVirtualized: true,\n  maxDepth: null,\n  treeNodeRenderer: null,\n  nodeContentRenderer: null,\n  onMoveNode: function onMoveNode() {},\n  onVisibilityToggle: function onVisibilityToggle() {},\n  placeholderRenderer: null,\n  reactVirtualizedListProps: {},\n  rowHeight: null,\n  scaffoldBlockPxWidth: null,\n  searchFinishCallback: null,\n  searchFocusOffset: null,\n  searchMethod: null,\n  searchQuery: null,\n  shouldCopyOnOutsideDrop: false,\n  slideRegionSize: null,\n  style: {},\n  theme: {},\n  onDragStateChanged: function onDragStateChanged() {},\n  onlyExpandSearchedNodes: false,\n  rowDirection: 'ltr'\n};\npolyfill(ReactSortableTree);\n\nvar SortableTreeWithoutDndContext = function SortableTreeWithoutDndContext(props) {\n  return React.createElement(DndContext.Consumer, null, function (_ref17) {\n    var dragDropManager = _ref17.dragDropManager;\n    return dragDropManager === undefined ? null : React.createElement(ReactSortableTree, _extends({}, props, {\n      dragDropManager: dragDropManager\n    }));\n  });\n};\n\nvar SortableTree = function SortableTree(props) {\n  return React.createElement(DndProvider, {\n    backend: HTML5Backend\n  }, React.createElement(SortableTreeWithoutDndContext, props));\n}; // Export the tree component without the react-dnd DragDropContext,\n\n\nexport default SortableTree;\nexport { SortableTreeWithoutDndContext, defaultGetNodeKey, defaultSearchMethod, getDescendantCount, getVisibleNodeCount, getVisibleNodeInfoAtIndex, walk, map, toggleExpandedForAll, changeNodeAtPath, removeNodeAtPath, removeNode, getNodeAtPath, addNodeUnderParent, insertNode, getFlatDataFromTree, getTreeFromFlatData, isDescendant, getDepth, find };","map":{"version":3,"sources":["/Users/pradeepkumar/Downloads/clicks-backend-master/node_modules/react-sortable-tree/dist/index.esm.js"],"names":["AutoSizer","List","isEqual","withScrolling","createScrollingComponent","createVerticalStrength","createHorizontalStrength","HTML5Backend","React","Component","Children","cloneElement","PropTypes","DragSource","DropTarget","DndProvider","DndContext","findDOMNode","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","value","_extends","assign","arguments","source","hasOwnProperty","call","apply","_objectSpread","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_objectWithoutPropertiesLoose","excluded","sourceKeys","indexOf","_objectWithoutProperties","sourceSymbolKeys","propertyIsEnumerable","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","arr2","iter","toString","from","componentWillMount","state","getDerivedStateFromProps","undefined","setState","componentWillReceiveProps","nextProps","updater","prevState","bind","componentWillUpdate","nextState","prevProps","__reactInternalSnapshotFlag","__reactInternalSnapshot","getSnapshotBeforeUpdate","__suppressDeprecationWarning","polyfill","Component$$1","isReactComponent","Error","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","componentName","displayName","name","newApiName","componentDidUpdate","componentDidUpdatePolyfill","maybeSnapshot","snapshot","classnames","_len","classes","_key","Boolean","join","TreeNode","_Component","render","_this$props","children","listIndex","swapFrom","swapLength","swapDepth","scaffoldBlockPxWidth","lowerSiblingCounts","connectDropTarget","isOver","draggedNode","canDrop","treeIndex","treeId","getPrevRow","node","path","rowDirection","otherProps","rowDirectionClass","scaffoldBlockCount","scaffold","lowerSiblingCount","lineClass","push","createElement","style","width","className","highlightLineClass","_style","right","left","map","child","defaultProps","propTypes","number","isRequired","string","arrayOf","func","bool","shape","oneOfType","getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","currentIndex","getNodeKey","_ref$path","_ref$lowerSiblingCoun","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","expanded","nextIndex","childIndex","childCount","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","selfInfo","callbackResult","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","nextTreeIndex","_result","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","removeNode","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","nextTreeData","_ref16","getNodeAtPath","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","addNodeUnderParent","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","expandParent","_ref19$addAsFirstChil","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref20","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","_nextNode","parentPath","_childIndex","_insertedTreeIndex","insertIndex","_nextNode2","pathFragment","newChildren","insertNode","_ref22","depth","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","getFlatDataFromTree","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","getTreeFromFlatData","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","NodeRendererDefault","toggleChildrenVisibility","connectDragPreview","connectDragSource","isDragging","canDrag","title","subtitle","isSearchMatch","isSearchFocus","buttons","didDrop","nodeTitle","nodeSubtitle","handle","_","dropEffect","isDraggedDescendant","isLandingPadActive","buttonStyle","height","type","onClick","opacity","btn","TreePlaceholder","drop","PlaceholderRendererDefault","memoize","f","savedArgsArray","savedKeysArray","savedResult","args","keysArray","sort","argsArray","arg","memoizedInsertNode","memoizedGetFlatDataFromTree","memoizedGetDescendantCount","slideRows","rows","fromIndex","toIndex","count","rowsWithoutMoved","defaultGetNodeKey","getReactElementText","stringSearch","String","defaultSearchMethod","DndManager","treeRef","getTargetDepth","dropTargetProps","monitor","component","dropTargetDepth","rowAbove","aboveNodeCannotHaveChildren","canNodeHaveChildren","min","blocksOffset","dragSourceInitialDepth","getItem","relativePosition","getBoundingClientRect","leftShift","getSourceClientOffset","x","round","direction","getDifferenceFromInitialOffset","maxDepth","draggedChildDepth","abovePath","aboveNode","customCanDrop","_monitor$getItem","addedResult","prevPath","prevParent","prevTreeIndex","nextPath","nextParent","wrapSource","el","_this","nodeDragSource","beginDrag","startDrag","endDrag","getDropResult","dropTargetNode","nodeDragSourcePropInjection","connect","dragSource","dragPreview","dndType","wrapTarget","_this2","nodeDropTarget","hover","needsRedraw","cancelAnimationFrame","rafId","requestAnimationFrame","dragHover","nodeDropTargetPropInjection","dragged","dropTarget","wrapPlaceholder","_this3","placeholderDropTarget","_monitor$getItem2","placeholderPropInjection","get","draggingTreeData","treeIdCounter","mergeTheme","merged","theme","innerStyle","reactVirtualizedListProps","overridableDefaults","nodeContentRenderer","placeholderRenderer","rowHeight","slideRegionSize","treeNodeRenderer","propKey","ReactSortableTree","_mergeTheme","isVirtualized","dndManager","treePlaceholderRenderer","scrollZoneVirtualList","vStrength","hStrength","draggedMinimumTreeIndex","draggedDepth","searchMatches","searchFocusTreeIndex","dragging","instanceProps","ignoreOneTreeUpdate","moveNode","handleDndMonitorChange","componentDidMount","loadLazyChildren","stateUpdate","search","clearMonitorSubscription","dragDropManager","getMonitor","subscribeToStateChange","onDragStateChanged","componentWillUnmount","getRows","targetNode","onChange","onVisibilityToggle","_insertNode","nextParentNode","onMoveNode","_removeNode","newDraggingTreeData","expandedParentPath","dropResult","_this4","resetTree","shouldCopy","shouldCopyOnOutsideDrop","copyNode","renderRow","row","matchKeys","_mergeTheme2","generateNodeProps","TreeNodeRenderer","NodeContentRenderer","nodeKey","callbackParams","nodeProps","rowCanDrag","sharedProps","_this5","_mergeTheme3","_this$state","swapTo","scrollToInfo","scrollToIndex","containerStyle","list","Placeholder","PlaceholderContent","ScrollZoneVirtualList","verticalStrength","horizontalStrength","speed","scrollToAlignment","onScroll","scrollTop","rowCount","estimatedRowSize","rowRenderer","rowStyle","newState","isTreeDataEqual","seekIndex","expand","singleSearch","searchFinishCallback","onlyExpandSearchedNodes","_find","expandedTreeData","loadCollapsedLazyChildren","done","childrenArray","oldNode","object","any","SortableTreeWithoutDndContext","Consumer","SortableTree","backend"],"mappings":"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","sourcesContent":["import { AutoSizer, List } from 'react-virtualized';\nimport isEqual from 'lodash.isequal';\nimport withScrolling, { createScrollingComponent, createVerticalStrength, createHorizontalStrength } from 'frontend-collective-react-dnd-scrollzone';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport React, { Component, Children, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { DragSource, DropTarget, DndProvider, DndContext } from 'react-dnd';\nimport { findDOMNode } from 'react-dom';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  }\n  // Binding \"this\" is important for shallow renderer support.\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(\n      prevProps,\n      prevState\n    );\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n}\n\n// React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component$$1) {\n  var prototype = Component$$1.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (\n    typeof Component$$1.getDerivedStateFromProps !== 'function' &&\n    typeof prototype.getSnapshotBeforeUpdate !== 'function'\n  ) {\n    return Component$$1;\n  }\n\n  // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n  if (\n    foundWillMountName !== null ||\n    foundWillReceivePropsName !== null ||\n    foundWillUpdateName !== null\n  ) {\n    var componentName = Component$$1.displayName || Component$$1.name;\n    var newApiName =\n      typeof Component$$1.getDerivedStateFromProps === 'function'\n        ? 'getDerivedStateFromProps()'\n        : 'getSnapshotBeforeUpdate()';\n\n    throw Error(\n      'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n        componentName +\n        ' uses ' +\n        newApiName +\n        ' but also contains the following legacy lifecycles:' +\n        (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') +\n        (foundWillReceivePropsName !== null\n          ? '\\n  ' + foundWillReceivePropsName\n          : '') +\n        (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') +\n        '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' +\n        'https://fb.me/react-async-component-lifecycle-hooks'\n    );\n  }\n\n  // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n  if (typeof Component$$1.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  }\n\n  // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error(\n        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'\n      );\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(\n      prevProps,\n      prevState,\n      maybeSnapshot\n    ) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag\n        ? this.__reactInternalSnapshot\n        : maybeSnapshot;\n\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component$$1;\n}\n\n// very simple className utility for creating a classname string...\n// Falsy arguments are ignored:\n//\n// const active = true\n// const className = classnames(\n//    \"class1\",\n//    !active && \"class2\",\n//    active && \"class3\"\n// ); // returns -> class1 class3\";\n//\nfunction classnames() {\n  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n    classes[_key] = arguments[_key];\n  }\n\n  // Use Boolean constructor as a filter callback\n  // Allows for loose type truthy/falsey checks\n  // Boolean(\"\") === false;\n  // Boolean(false) === false;\n  // Boolean(undefined) === false;\n  // Boolean(null) === false;\n  // Boolean(0) === false;\n  // Boolean(\"classname\") === true;\n  return classes.filter(Boolean).join(' ');\n}\n\nvar TreeNode =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TreeNode, _Component);\n\n  function TreeNode() {\n    _classCallCheck(this, TreeNode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TreeNode).apply(this, arguments));\n  }\n\n  _createClass(TreeNode, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          listIndex = _this$props.listIndex,\n          swapFrom = _this$props.swapFrom,\n          swapLength = _this$props.swapLength,\n          swapDepth = _this$props.swapDepth,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          lowerSiblingCounts = _this$props.lowerSiblingCounts,\n          connectDropTarget = _this$props.connectDropTarget,\n          isOver = _this$props.isOver,\n          draggedNode = _this$props.draggedNode,\n          canDrop = _this$props.canDrop,\n          treeIndex = _this$props.treeIndex,\n          treeId = _this$props.treeId,\n          getPrevRow = _this$props.getPrevRow,\n          node = _this$props.node,\n          path = _this$props.path,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"listIndex\", \"swapFrom\", \"swapLength\", \"swapDepth\", \"scaffoldBlockPxWidth\", \"lowerSiblingCounts\", \"connectDropTarget\", \"isOver\", \"draggedNode\", \"canDrop\", \"treeIndex\", \"treeId\", \"getPrevRow\", \"node\", \"path\", \"rowDirection\"]);\n\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null; // Construct the scaffold representing the structure of the tree\n\n      var scaffoldBlockCount = lowerSiblingCounts.length;\n      var scaffold = [];\n      lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n        var lineClass = '';\n\n        if (lowerSiblingCount > 0) {\n          // At this level in the tree, the nodes had sibling nodes further down\n          if (listIndex === 0) {\n            // Top-left corner of the tree\n            // +-----+\n            // |     |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineHalfVerticalBottom';\n          } else if (i === scaffoldBlockCount - 1) {\n            // Last scaffold block in the row, right before the row content\n            // +--+--+\n            // |  |  |\n            // |  +--+\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineHalfHorizontalRight rst__lineFullVertical';\n          } else {\n            // Simply connecting the line extending down to the next sibling on this level\n            // +--+--+\n            // |  |  |\n            // |  |  |\n            // |  |  |\n            // +--+--+\n            lineClass = 'rst__lineFullVertical';\n          }\n        } else if (listIndex === 0) {\n          // Top-left corner of the tree, but has no siblings\n          // +-----+\n          // |     |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfHorizontalRight';\n        } else if (i === scaffoldBlockCount - 1) {\n          // The last or only node in this level of the tree\n          // +--+--+\n          // |  |  |\n          // |  +--+\n          // |     |\n          // +-----+\n          lineClass = 'rst__lineHalfVerticalTop rst__lineHalfHorizontalRight';\n        }\n\n        scaffold.push(React.createElement(\"div\", {\n          key: \"pre_\".concat(1 + i),\n          style: {\n            width: scaffoldBlockPxWidth\n          },\n          className: classnames('rst__lineBlock', lineClass, rowDirectionClass)\n        }));\n\n        if (treeIndex !== listIndex && i === swapDepth) {\n          // This row has been shifted, and is at the depth of\n          // the line pointing to the new destination\n          var highlightLineClass = '';\n\n          if (listIndex === swapFrom + swapLength - 1) {\n            // This block is on the bottom (target) line\n            // This block points at the target block (where the row will go when released)\n            highlightLineClass = 'rst__highlightBottomLeftCorner';\n          } else if (treeIndex === swapFrom) {\n            // This block is on the top (source) line\n            highlightLineClass = 'rst__highlightTopLeftCorner';\n          } else {\n            // This block is between the bottom and top\n            highlightLineClass = 'rst__highlightLineVertical';\n          }\n\n          var _style;\n\n          if (rowDirection === 'rtl') {\n            _style = {\n              width: scaffoldBlockPxWidth,\n              right: scaffoldBlockPxWidth * i\n            };\n          } else {\n            // Default ltr\n            _style = {\n              width: scaffoldBlockPxWidth,\n              left: scaffoldBlockPxWidth * i\n            };\n          }\n\n          scaffold.push(React.createElement(\"div\", {\n            // eslint-disable-next-line react/no-array-index-key\n            key: i,\n            style: _style,\n            className: classnames('rst__absoluteLineBlock', highlightLineClass, rowDirectionClass)\n          }));\n        }\n      });\n      var style;\n\n      if (rowDirection === 'rtl') {\n        style = {\n          right: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      } else {\n        // Default ltr\n        style = {\n          left: scaffoldBlockPxWidth * scaffoldBlockCount\n        };\n      }\n\n      return connectDropTarget(React.createElement(\"div\", _extends({}, otherProps, {\n        className: classnames('rst__node', rowDirectionClass)\n      }), scaffold, React.createElement(\"div\", {\n        className: \"rst__nodeContent\",\n        style: style\n      }, Children.map(children, function (child) {\n        return cloneElement(child, {\n          isOver: isOver,\n          canDrop: canDrop,\n          draggedNode: draggedNode\n        });\n      }))));\n    }\n  }]);\n\n  return TreeNode;\n}(Component);\n\nTreeNode.defaultProps = {\n  swapFrom: null,\n  swapDepth: null,\n  swapLength: null,\n  canDrop: false,\n  draggedNode: null,\n  rowDirection: 'ltr'\n};\nTreeNode.propTypes = {\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  swapFrom: PropTypes.number,\n  swapDepth: PropTypes.number,\n  swapLength: PropTypes.number,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  lowerSiblingCounts: PropTypes.arrayOf(PropTypes.number).isRequired,\n  listIndex: PropTypes.number.isRequired,\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  // used in dndManager\n  getPrevRow: PropTypes.func.isRequired,\n  node: PropTypes.shape({}).isRequired,\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n  var targetIndex = _ref.targetIndex,\n      node = _ref.node,\n      currentIndex = _ref.currentIndex,\n      getNodeKey = _ref.getNodeKey,\n      _ref$path = _ref.path,\n      path = _ref$path === void 0 ? [] : _ref$path,\n      _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n      lowerSiblingCounts = _ref$lowerSiblingCoun === void 0 ? [] : _ref$lowerSiblingCoun,\n      _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n      ignoreCollapsed = _ref$ignoreCollapsed === void 0 ? true : _ref$ignoreCollapsed,\n      _ref$isPseudoRoot = _ref.isPseudoRoot,\n      isPseudoRoot = _ref$isPseudoRoot === void 0 ? false : _ref$isPseudoRoot;\n  // The pseudo-root is not considered in the path\n  var selfPath = !isPseudoRoot ? _toConsumableArray(path).concat([getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]) : []; // Return target node when found\n\n  if (currentIndex === targetIndex) {\n    return {\n      node: node,\n      lowerSiblingCounts: lowerSiblingCounts,\n      path: selfPath\n    };\n  } // Add one and continue for nodes with no children or hidden children\n\n\n  if (!node.children || ignoreCollapsed && node.expanded !== true) {\n    return {\n      nextIndex: currentIndex + 1\n    };\n  } // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n\n\n  var childIndex = currentIndex + 1;\n  var childCount = node.children.length;\n\n  for (var i = 0; i < childCount; i += 1) {\n    var result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed: ignoreCollapsed,\n      getNodeKey: getNodeKey,\n      targetIndex: targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n      path: selfPath\n    });\n\n    if (result.node) {\n      return result;\n    }\n\n    childIndex = result.nextIndex;\n  } // If the target node is not found, return the farthest traversed index\n\n\n  return {\n    nextIndex: childIndex\n  };\n}\n\nfunction getDescendantCount(_ref2) {\n  var node = _ref2.node,\n      _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n      ignoreCollapsed = _ref2$ignoreCollapsed === void 0 ? true : _ref2$ignoreCollapsed;\n  return getNodeDataAtTreeIndexOrNextIndex({\n    getNodeKey: function getNodeKey() {},\n    ignoreCollapsed: ignoreCollapsed,\n    node: node,\n    currentIndex: 0,\n    targetIndex: -1\n  }).nextIndex - 1;\n}\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\nfunction walkDescendants(_ref3) {\n  var callback = _ref3.callback,\n      getNodeKey = _ref3.getNodeKey,\n      ignoreCollapsed = _ref3.ignoreCollapsed,\n      _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n      isPseudoRoot = _ref3$isPseudoRoot === void 0 ? false : _ref3$isPseudoRoot,\n      node = _ref3.node,\n      _ref3$parentNode = _ref3.parentNode,\n      parentNode = _ref3$parentNode === void 0 ? null : _ref3$parentNode,\n      currentIndex = _ref3.currentIndex,\n      _ref3$path = _ref3.path,\n      path = _ref3$path === void 0 ? [] : _ref3$path,\n      _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n      lowerSiblingCounts = _ref3$lowerSiblingCou === void 0 ? [] : _ref3$lowerSiblingCou;\n  // The pseudo-root is not considered in the path\n  var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n    node: node,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = isPseudoRoot ? null : {\n    node: node,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  };\n\n  if (!isPseudoRoot) {\n    var callbackResult = callback(selfInfo); // Cut walk short if the callback returned false\n\n    if (callbackResult === false) {\n      return false;\n    }\n  } // Return self on nodes with no children or hidden children\n\n\n  if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return currentIndex;\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = node.children.length;\n\n  if (typeof node.children !== 'function') {\n    for (var i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n        path: selfPath\n      }); // Cut walk short if the callback returned false\n\n      if (childIndex === false) {\n        return false;\n      }\n    }\n  }\n\n  return childIndex;\n}\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\n\n\nfunction mapDescendants(_ref4) {\n  var callback = _ref4.callback,\n      getNodeKey = _ref4.getNodeKey,\n      ignoreCollapsed = _ref4.ignoreCollapsed,\n      _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n      isPseudoRoot = _ref4$isPseudoRoot === void 0 ? false : _ref4$isPseudoRoot,\n      node = _ref4.node,\n      _ref4$parentNode = _ref4.parentNode,\n      parentNode = _ref4$parentNode === void 0 ? null : _ref4$parentNode,\n      currentIndex = _ref4.currentIndex,\n      _ref4$path = _ref4.path,\n      path = _ref4$path === void 0 ? [] : _ref4$path,\n      _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n      lowerSiblingCounts = _ref4$lowerSiblingCou === void 0 ? [] : _ref4$lowerSiblingCou;\n\n  var nextNode = _objectSpread({}, node); // The pseudo-root is not considered in the path\n\n\n  var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n    node: nextNode,\n    treeIndex: currentIndex\n  })]);\n  var selfInfo = {\n    node: nextNode,\n    parentNode: parentNode,\n    path: selfPath,\n    lowerSiblingCounts: lowerSiblingCounts,\n    treeIndex: currentIndex\n  }; // Return self on nodes with no children or hidden children\n\n  if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    };\n  } // Get all descendants\n\n\n  var childIndex = currentIndex;\n  var childCount = nextNode.children.length;\n\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map(function (child, i) {\n      var mapResult = mapDescendants({\n        callback: callback,\n        getNodeKey: getNodeKey,\n        ignoreCollapsed: ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: _toConsumableArray(lowerSiblingCounts).concat([childCount - i - 1]),\n        path: selfPath\n      });\n      childIndex = mapResult.treeIndex;\n      return mapResult.node;\n    });\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  };\n}\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\n\n\nfunction getVisibleNodeCount(_ref5) {\n  var treeData = _ref5.treeData;\n\n  var traverse = function traverse(node) {\n    if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n      return 1;\n    }\n\n    return 1 + node.children.reduce(function (total, currentNode) {\n      return total + traverse(currentNode);\n    }, 0);\n  };\n\n  return treeData.reduce(function (total, currentNode) {\n    return total + traverse(currentNode);\n  }, 0);\n}\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\n\nfunction getVisibleNodeInfoAtIndex(_ref6) {\n  var treeData = _ref6.treeData,\n      targetIndex = _ref6.index,\n      getNodeKey = _ref6.getNodeKey;\n\n  if (!treeData || treeData.length < 1) {\n    return null;\n  } // Call the tree traversal with a pseudo-root node\n\n\n  var result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex: targetIndex,\n    getNodeKey: getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  });\n\n  if (result.node) {\n    return result;\n  }\n\n  return null;\n}\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\n\nfunction walk(_ref7) {\n  var treeData = _ref7.treeData,\n      getNodeKey = _ref7.getNodeKey,\n      callback = _ref7.callback,\n      _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n      ignoreCollapsed = _ref7$ignoreCollapsed === void 0 ? true : _ref7$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return;\n  }\n\n  walkDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  });\n}\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nfunction map(_ref8) {\n  var treeData = _ref8.treeData,\n      getNodeKey = _ref8.getNodeKey,\n      callback = _ref8.callback,\n      _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n      ignoreCollapsed = _ref8$ignoreCollapsed === void 0 ? true : _ref8$ignoreCollapsed;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  return mapDescendants({\n    callback: callback,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    isPseudoRoot: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children;\n}\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nfunction toggleExpandedForAll(_ref9) {\n  var treeData = _ref9.treeData,\n      _ref9$expanded = _ref9.expanded,\n      expanded = _ref9$expanded === void 0 ? true : _ref9$expanded;\n  return map({\n    treeData: treeData,\n    callback: function callback(_ref10) {\n      var node = _ref10.node;\n      return _objectSpread({}, node, {\n        expanded: expanded\n      });\n    },\n    getNodeKey: function getNodeKey(_ref11) {\n      var treeIndex = _ref11.treeIndex;\n      return treeIndex;\n    },\n    ignoreCollapsed: false\n  });\n}\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\n\nfunction changeNodeAtPath(_ref12) {\n  var treeData = _ref12.treeData,\n      path = _ref12.path,\n      newNode = _ref12.newNode,\n      getNodeKey = _ref12.getNodeKey,\n      _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n      ignoreCollapsed = _ref12$ignoreCollapse === void 0 ? true : _ref12$ignoreCollapse;\n  var RESULT_MISS = 'RESULT_MISS';\n\n  var traverse = function traverse(_ref13) {\n    var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n        isPseudoRoot = _ref13$isPseudoRoot === void 0 ? false : _ref13$isPseudoRoot,\n        node = _ref13.node,\n        currentTreeIndex = _ref13.currentTreeIndex,\n        pathIndex = _ref13.pathIndex;\n\n    if (!isPseudoRoot && getNodeKey({\n      node: node,\n      treeIndex: currentTreeIndex\n    }) !== path[pathIndex]) {\n      return RESULT_MISS;\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function' ? newNode({\n        node: node,\n        treeIndex: currentTreeIndex\n      }) : newNode;\n    }\n\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.');\n    }\n\n    var nextTreeIndex = currentTreeIndex + 1;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      var _result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      }); // If the result went down the correct path\n\n\n      if (_result !== RESULT_MISS) {\n        if (_result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return _objectSpread({}, node, {\n            children: _toConsumableArray(node.children.slice(0, i)).concat([_result], _toConsumableArray(node.children.slice(i + 1)))\n          });\n        } // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n\n\n        return _objectSpread({}, node, {\n          children: _toConsumableArray(node.children.slice(0, i)).concat(_toConsumableArray(node.children.slice(i + 1)))\n        });\n      }\n\n      nextTreeIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    }\n\n    return RESULT_MISS;\n  }; // Use a pseudo-root node in the beginning traversal\n\n\n  var result = traverse({\n    node: {\n      children: treeData\n    },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  });\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.');\n  }\n\n  return result.children;\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\n\nfunction removeNodeAtPath(_ref14) {\n  var treeData = _ref14.treeData,\n      path = _ref14.path,\n      getNodeKey = _ref14.getNodeKey,\n      _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n      ignoreCollapsed = _ref14$ignoreCollapse === void 0 ? true : _ref14$ignoreCollapse;\n  return changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: null // Delete the node\n\n  });\n}\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\n\nfunction removeNode(_ref15) {\n  var treeData = _ref15.treeData,\n      path = _ref15.path,\n      getNodeKey = _ref15.getNodeKey,\n      _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n      ignoreCollapsed = _ref15$ignoreCollapse === void 0 ? true : _ref15$ignoreCollapse;\n  var removedNode = null;\n  var removedTreeIndex = null;\n  var nextTreeData = changeNodeAtPath({\n    treeData: treeData,\n    path: path,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    newNode: function newNode(_ref16) {\n      var node = _ref16.node,\n          treeIndex = _ref16.treeIndex;\n      // Store the target node and delete it from the tree\n      removedNode = node;\n      removedTreeIndex = treeIndex;\n      return null;\n    }\n  });\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  };\n}\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\n\nfunction getNodeAtPath(_ref17) {\n  var treeData = _ref17.treeData,\n      path = _ref17.path,\n      getNodeKey = _ref17.getNodeKey,\n      _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n      ignoreCollapsed = _ref17$ignoreCollapse === void 0 ? true : _ref17$ignoreCollapse;\n  var foundNodeInfo = null;\n\n  try {\n    changeNodeAtPath({\n      treeData: treeData,\n      path: path,\n      getNodeKey: getNodeKey,\n      ignoreCollapsed: ignoreCollapsed,\n      newNode: function newNode(_ref18) {\n        var node = _ref18.node,\n            treeIndex = _ref18.treeIndex;\n        foundNodeInfo = {\n          node: node,\n          treeIndex: treeIndex\n        };\n        return node;\n      }\n    });\n  } catch (err) {// Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo;\n}\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\n\nfunction addNodeUnderParent(_ref19) {\n  var treeData = _ref19.treeData,\n      newNode = _ref19.newNode,\n      _ref19$parentKey = _ref19.parentKey,\n      parentKey = _ref19$parentKey === void 0 ? null : _ref19$parentKey,\n      getNodeKey = _ref19.getNodeKey,\n      _ref19$ignoreCollapse = _ref19.ignoreCollapsed,\n      ignoreCollapsed = _ref19$ignoreCollapse === void 0 ? true : _ref19$ignoreCollapse,\n      _ref19$expandParent = _ref19.expandParent,\n      expandParent = _ref19$expandParent === void 0 ? false : _ref19$expandParent,\n      _ref19$addAsFirstChil = _ref19.addAsFirstChild,\n      addAsFirstChild = _ref19$addAsFirstChil === void 0 ? false : _ref19$addAsFirstChil;\n\n  if (parentKey === null) {\n    return addAsFirstChild ? {\n      treeData: [newNode].concat(_toConsumableArray(treeData || [])),\n      treeIndex: 0\n    } : {\n      treeData: _toConsumableArray(treeData || []).concat([newNode]),\n      treeIndex: (treeData || []).length\n    };\n  }\n\n  var insertedTreeIndex = null;\n  var hasBeenAdded = false;\n  var changedTreeData = map({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(_ref20) {\n      var node = _ref20.node,\n          treeIndex = _ref20.treeIndex,\n          path = _ref20.path;\n      var key = path ? path[path.length - 1] : null; // Return nodes that are not the parent as-is\n\n      if (hasBeenAdded || key !== parentKey) {\n        return node;\n      }\n\n      hasBeenAdded = true;\n\n      var parentNode = _objectSpread({}, node);\n\n      if (expandParent) {\n        parentNode.expanded = true;\n      } // If no children exist yet, just add the single newNode\n\n\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1;\n        return _objectSpread({}, parentNode, {\n          children: [newNode]\n        });\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function');\n      }\n\n      var nextTreeIndex = treeIndex + 1;\n\n      for (var i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex += 1 + getDescendantCount({\n          node: parentNode.children[i],\n          ignoreCollapsed: ignoreCollapsed\n        });\n      }\n\n      insertedTreeIndex = nextTreeIndex;\n      var children = addAsFirstChild ? [newNode].concat(_toConsumableArray(parentNode.children)) : _toConsumableArray(parentNode.children).concat([newNode]);\n      return _objectSpread({}, parentNode, {\n        children: children\n      });\n    }\n  });\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.');\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  };\n}\n\nfunction addNodeAtDepthAndIndex(_ref21) {\n  var targetDepth = _ref21.targetDepth,\n      minimumTreeIndex = _ref21.minimumTreeIndex,\n      newNode = _ref21.newNode,\n      ignoreCollapsed = _ref21.ignoreCollapsed,\n      expandParent = _ref21.expandParent,\n      _ref21$isPseudoRoot = _ref21.isPseudoRoot,\n      isPseudoRoot = _ref21$isPseudoRoot === void 0 ? false : _ref21$isPseudoRoot,\n      isLastChild = _ref21.isLastChild,\n      node = _ref21.node,\n      currentIndex = _ref21.currentIndex,\n      currentDepth = _ref21.currentDepth,\n      getNodeKey = _ref21.getNodeKey,\n      _ref21$path = _ref21.path,\n      path = _ref21$path === void 0 ? [] : _ref21$path;\n\n  var selfPath = function selfPath(n) {\n    return isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n      node: n,\n      treeIndex: currentIndex\n    })]);\n  }; // If the current position is the only possible place to add, add it\n\n\n  if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function');\n    } else {\n      var extraNodeProps = expandParent ? {\n        expanded: true\n      } : {};\n\n      var _nextNode = _objectSpread({}, node, extraNodeProps, {\n        children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n      });\n\n      return {\n        node: _nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(_nextNode),\n        parentNode: isPseudoRoot ? null : _nextNode\n      };\n    }\n  } // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n\n\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n      return {\n        node: node,\n        nextIndex: currentIndex + 1\n      };\n    } // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n\n\n    var _childIndex = currentIndex + 1;\n\n    var _insertedTreeIndex = null;\n    var insertIndex = null;\n\n    for (var i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (_childIndex >= minimumTreeIndex) {\n        _insertedTreeIndex = _childIndex;\n        insertIndex = i;\n        break;\n      } // Increment the index by the child itself plus the number of descendants it has\n\n\n      _childIndex += 1 + getDescendantCount({\n        node: node.children[i],\n        ignoreCollapsed: ignoreCollapsed\n      });\n    } // If no valid indices to add the node were found\n\n\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (_childIndex < minimumTreeIndex && !isLastChild) {\n        return {\n          node: node,\n          nextIndex: _childIndex\n        };\n      } // Use the last position in the children array to insert the newNode\n\n\n      _insertedTreeIndex = _childIndex;\n      insertIndex = node.children.length;\n    } // Insert the newNode at the insertIndex\n\n\n    var _nextNode2 = _objectSpread({}, node, {\n      children: _toConsumableArray(node.children.slice(0, insertIndex)).concat([newNode], _toConsumableArray(node.children.slice(insertIndex)))\n    }); // Return node with successful insert result\n\n\n    return {\n      node: _nextNode2,\n      nextIndex: _childIndex,\n      insertedTreeIndex: _insertedTreeIndex,\n      parentPath: selfPath(_nextNode2),\n      parentNode: isPseudoRoot ? null : _nextNode2\n    };\n  } // Skip over nodes with no children or hidden children\n\n\n  if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n    return {\n      node: node,\n      nextIndex: currentIndex + 1\n    };\n  } // Get all descendants\n\n\n  var insertedTreeIndex = null;\n  var pathFragment = null;\n  var parentNode = null;\n  var childIndex = currentIndex + 1;\n  var newChildren = node.children;\n\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map(function (child, i) {\n      if (insertedTreeIndex !== null) {\n        return child;\n      }\n\n      var mapResult = addNodeAtDepthAndIndex({\n        targetDepth: targetDepth,\n        minimumTreeIndex: minimumTreeIndex,\n        newNode: newNode,\n        ignoreCollapsed: ignoreCollapsed,\n        expandParent: expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey: getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n\n      });\n\n      if ('insertedTreeIndex' in mapResult) {\n        insertedTreeIndex = mapResult.insertedTreeIndex;\n        parentNode = mapResult.parentNode;\n        pathFragment = mapResult.parentPath;\n      }\n\n      childIndex = mapResult.nextIndex;\n      return mapResult.node;\n    });\n  }\n\n  var nextNode = _objectSpread({}, node, {\n    children: newChildren\n  });\n\n  var result = {\n    node: nextNode,\n    nextIndex: childIndex\n  };\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex;\n    result.parentPath = _toConsumableArray(selfPath(nextNode)).concat(_toConsumableArray(pathFragment));\n    result.parentNode = parentNode;\n  }\n\n  return result;\n}\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\n\n\nfunction insertNode(_ref22) {\n  var treeData = _ref22.treeData,\n      targetDepth = _ref22.depth,\n      minimumTreeIndex = _ref22.minimumTreeIndex,\n      newNode = _ref22.newNode,\n      _ref22$getNodeKey = _ref22.getNodeKey,\n      getNodeKey = _ref22$getNodeKey === void 0 ? function () {} : _ref22$getNodeKey,\n      _ref22$ignoreCollapse = _ref22.ignoreCollapsed,\n      ignoreCollapsed = _ref22$ignoreCollapse === void 0 ? true : _ref22$ignoreCollapse,\n      _ref22$expandParent = _ref22.expandParent,\n      expandParent = _ref22$expandParent === void 0 ? false : _ref22$expandParent;\n\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({\n        node: newNode,\n        treeIndex: 0\n      })],\n      parentNode: null\n    };\n  }\n\n  var insertResult = addNodeAtDepthAndIndex({\n    targetDepth: targetDepth,\n    minimumTreeIndex: minimumTreeIndex,\n    newNode: newNode,\n    ignoreCollapsed: ignoreCollapsed,\n    expandParent: expandParent,\n    getNodeKey: getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: {\n      children: treeData\n    },\n    currentIndex: -1,\n    currentDepth: -1\n  });\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.');\n  }\n\n  var treeIndex = insertResult.insertedTreeIndex;\n  return {\n    treeData: insertResult.node.children,\n    treeIndex: treeIndex,\n    path: _toConsumableArray(insertResult.parentPath).concat([getNodeKey({\n      node: newNode,\n      treeIndex: treeIndex\n    })]),\n    parentNode: insertResult.parentNode\n  };\n}\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\n\nfunction getFlatDataFromTree(_ref23) {\n  var treeData = _ref23.treeData,\n      getNodeKey = _ref23.getNodeKey,\n      _ref23$ignoreCollapse = _ref23.ignoreCollapsed,\n      ignoreCollapsed = _ref23$ignoreCollapse === void 0 ? true : _ref23$ignoreCollapse;\n\n  if (!treeData || treeData.length < 1) {\n    return [];\n  }\n\n  var flattened = [];\n  walk({\n    treeData: treeData,\n    getNodeKey: getNodeKey,\n    ignoreCollapsed: ignoreCollapsed,\n    callback: function callback(nodeInfo) {\n      flattened.push(nodeInfo);\n    }\n  });\n  return flattened;\n}\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\n\nfunction getTreeFromFlatData(_ref24) {\n  var flatData = _ref24.flatData,\n      _ref24$getKey = _ref24.getKey,\n      getKey = _ref24$getKey === void 0 ? function (node) {\n    return node.id;\n  } : _ref24$getKey,\n      _ref24$getParentKey = _ref24.getParentKey,\n      getParentKey = _ref24$getParentKey === void 0 ? function (node) {\n    return node.parentId;\n  } : _ref24$getParentKey,\n      _ref24$rootKey = _ref24.rootKey,\n      rootKey = _ref24$rootKey === void 0 ? '0' : _ref24$rootKey;\n\n  if (!flatData) {\n    return [];\n  }\n\n  var childrenToParents = {};\n  flatData.forEach(function (child) {\n    var parentKey = getParentKey(child);\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child);\n    } else {\n      childrenToParents[parentKey] = [child];\n    }\n  });\n\n  if (!(rootKey in childrenToParents)) {\n    return [];\n  }\n\n  var trav = function trav(parent) {\n    var parentKey = getKey(parent);\n\n    if (parentKey in childrenToParents) {\n      return _objectSpread({}, parent, {\n        children: childrenToParents[parentKey].map(function (child) {\n          return trav(child);\n        })\n      });\n    }\n\n    return _objectSpread({}, parent);\n  };\n\n  return childrenToParents[rootKey].map(function (child) {\n    return trav(child);\n  });\n}\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\n\nfunction isDescendant(older, younger) {\n  return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n    return child === younger || isDescendant(child, younger);\n  });\n}\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\n\nfunction getDepth(node) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (!node.children) {\n    return depth;\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1;\n  }\n\n  return node.children.reduce(function (deepest, child) {\n    return Math.max(deepest, getDepth(child, depth + 1));\n  }, depth);\n}\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\n\nfunction find(_ref25) {\n  var getNodeKey = _ref25.getNodeKey,\n      treeData = _ref25.treeData,\n      searchQuery = _ref25.searchQuery,\n      searchMethod = _ref25.searchMethod,\n      searchFocusOffset = _ref25.searchFocusOffset,\n      _ref25$expandAllMatch = _ref25.expandAllMatchPaths,\n      expandAllMatchPaths = _ref25$expandAllMatch === void 0 ? false : _ref25$expandAllMatch,\n      _ref25$expandFocusMat = _ref25.expandFocusMatchPaths,\n      expandFocusMatchPaths = _ref25$expandFocusMat === void 0 ? true : _ref25$expandFocusMat;\n  var matchCount = 0;\n\n  var trav = function trav(_ref26) {\n    var _ref26$isPseudoRoot = _ref26.isPseudoRoot,\n        isPseudoRoot = _ref26$isPseudoRoot === void 0 ? false : _ref26$isPseudoRoot,\n        node = _ref26.node,\n        currentIndex = _ref26.currentIndex,\n        _ref26$path = _ref26.path,\n        path = _ref26$path === void 0 ? [] : _ref26$path;\n    var matches = [];\n    var isSelfMatch = false;\n    var hasFocusMatch = false; // The pseudo-root is not considered in the path\n\n    var selfPath = isPseudoRoot ? [] : _toConsumableArray(path).concat([getNodeKey({\n      node: node,\n      treeIndex: currentIndex\n    })]);\n    var extraInfo = isPseudoRoot ? null : {\n      path: selfPath,\n      treeIndex: currentIndex\n    }; // Nodes with with children that aren't lazy\n\n    var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0; // Examine the current node to see if it is a match\n\n    if (!isPseudoRoot && searchMethod(_objectSpread({}, extraInfo, {\n      node: node,\n      searchQuery: searchQuery\n    }))) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true;\n      } // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n\n\n      matchCount += 1; // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n\n      isSelfMatch = true;\n    }\n\n    var childIndex = currentIndex;\n\n    var newNode = _objectSpread({}, node);\n\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map(function (child) {\n        var mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        }); // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex;\n        } else {\n          childIndex += 1;\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = _toConsumableArray(matches).concat(_toConsumableArray(mapResult.matches));\n\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true;\n          } // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n\n\n          if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n            newNode.expanded = true;\n          }\n        }\n\n        return mapResult.node;\n      });\n    } // Cannot assign a treeIndex to hidden nodes\n\n\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map(function (match) {\n        return _objectSpread({}, match, {\n          treeIndex: null\n        });\n      });\n    } // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n\n\n    if (isSelfMatch) {\n      matches = [_objectSpread({}, extraInfo, {\n        node: newNode\n      })].concat(_toConsumableArray(matches));\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches: matches,\n      hasFocusMatch: hasFocusMatch,\n      treeIndex: childIndex\n    };\n  };\n\n  var result = trav({\n    node: {\n      children: treeData\n    },\n    isPseudoRoot: true,\n    currentIndex: -1\n  });\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  };\n}\n\nvar NodeRendererDefault =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(NodeRendererDefault, _Component);\n\n  function NodeRendererDefault() {\n    _classCallCheck(this, NodeRendererDefault);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NodeRendererDefault).apply(this, arguments));\n  }\n\n  _createClass(NodeRendererDefault, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          scaffoldBlockPxWidth = _this$props.scaffoldBlockPxWidth,\n          toggleChildrenVisibility = _this$props.toggleChildrenVisibility,\n          connectDragPreview = _this$props.connectDragPreview,\n          connectDragSource = _this$props.connectDragSource,\n          isDragging = _this$props.isDragging,\n          canDrop = _this$props.canDrop,\n          canDrag = _this$props.canDrag,\n          node = _this$props.node,\n          title = _this$props.title,\n          subtitle = _this$props.subtitle,\n          draggedNode = _this$props.draggedNode,\n          path = _this$props.path,\n          treeIndex = _this$props.treeIndex,\n          isSearchMatch = _this$props.isSearchMatch,\n          isSearchFocus = _this$props.isSearchFocus,\n          buttons = _this$props.buttons,\n          className = _this$props.className,\n          style = _this$props.style,\n          didDrop = _this$props.didDrop,\n          treeId = _this$props.treeId,\n          isOver = _this$props.isOver,\n          parentNode = _this$props.parentNode,\n          rowDirection = _this$props.rowDirection,\n          otherProps = _objectWithoutProperties(_this$props, [\"scaffoldBlockPxWidth\", \"toggleChildrenVisibility\", \"connectDragPreview\", \"connectDragSource\", \"isDragging\", \"canDrop\", \"canDrag\", \"node\", \"title\", \"subtitle\", \"draggedNode\", \"path\", \"treeIndex\", \"isSearchMatch\", \"isSearchFocus\", \"buttons\", \"className\", \"style\", \"didDrop\", \"treeId\", \"isOver\", \"parentNode\", \"rowDirection\"]);\n\n      var nodeTitle = title || node.title;\n      var nodeSubtitle = subtitle || node.subtitle;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var handle;\n\n      if (canDrag) {\n        if (typeof node.children === 'function' && node.expanded) {\n          // Show a loading symbol on the handle when the children are expanded\n          //  and yet still defined by a function (a callback to fetch the children)\n          handle = React.createElement(\"div\", {\n            className: \"rst__loadingHandle\"\n          }, React.createElement(\"div\", {\n            className: \"rst__loadingCircle\"\n          }, _toConsumableArray(new Array(12)).map(function (_, index) {\n            return React.createElement(\"div\", {\n              // eslint-disable-next-line react/no-array-index-key\n              key: index,\n              className: classnames('rst__loadingCirclePoint', rowDirectionClass)\n            });\n          })));\n        } else {\n          // Show the handle used to initiate a drag-and-drop\n          handle = connectDragSource(React.createElement(\"div\", {\n            className: \"rst__moveHandle\"\n          }), {\n            dropEffect: 'copy'\n          });\n        }\n      }\n\n      var isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\n      var isLandingPadActive = !didDrop && isDragging;\n      var buttonStyle = {\n        left: -0.5 * scaffoldBlockPxWidth\n      };\n\n      if (rowDirection === 'rtl') {\n        buttonStyle = {\n          right: -0.5 * scaffoldBlockPxWidth\n        };\n      }\n\n      return React.createElement(\"div\", _extends({\n        style: {\n          height: '100%'\n        }\n      }, otherProps), toggleChildrenVisibility && node.children && (node.children.length > 0 || typeof node.children === 'function') && React.createElement(\"div\", null, React.createElement(\"button\", {\n        type: \"button\",\n        \"aria-label\": node.expanded ? 'Collapse' : 'Expand',\n        className: classnames(node.expanded ? 'rst__collapseButton' : 'rst__expandButton', rowDirectionClass),\n        style: buttonStyle,\n        onClick: function onClick() {\n          return toggleChildrenVisibility({\n            node: node,\n            path: path,\n            treeIndex: treeIndex\n          });\n        }\n      }), node.expanded && !isDragging && React.createElement(\"div\", {\n        style: {\n          width: scaffoldBlockPxWidth\n        },\n        className: classnames('rst__lineChildren', rowDirectionClass)\n      })), React.createElement(\"div\", {\n        className: classnames('rst__rowWrapper', rowDirectionClass)\n      }, connectDragPreview(React.createElement(\"div\", {\n        className: classnames('rst__row', isLandingPadActive && 'rst__rowLandingPad', isLandingPadActive && !canDrop && 'rst__rowCancelPad', isSearchMatch && 'rst__rowSearchMatch', isSearchFocus && 'rst__rowSearchFocus', rowDirectionClass, className),\n        style: _objectSpread({\n          opacity: isDraggedDescendant ? 0.5 : 1\n        }, style)\n      }, handle, React.createElement(\"div\", {\n        className: classnames('rst__rowContents', !canDrag && 'rst__rowContentsDragDisabled', rowDirectionClass)\n      }, React.createElement(\"div\", {\n        className: classnames('rst__rowLabel', rowDirectionClass)\n      }, React.createElement(\"span\", {\n        className: classnames('rst__rowTitle', node.subtitle && 'rst__rowTitleWithSubtitle')\n      }, typeof nodeTitle === 'function' ? nodeTitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeTitle), nodeSubtitle && React.createElement(\"span\", {\n        className: \"rst__rowSubtitle\"\n      }, typeof nodeSubtitle === 'function' ? nodeSubtitle({\n        node: node,\n        path: path,\n        treeIndex: treeIndex\n      }) : nodeSubtitle)), React.createElement(\"div\", {\n        className: \"rst__rowToolbar\"\n      }, buttons.map(function (btn, index) {\n        return React.createElement(\"div\", {\n          key: index // eslint-disable-line react/no-array-index-key\n          ,\n          className: \"rst__toolbarButton\"\n        }, btn);\n      })))))));\n    }\n  }]);\n\n  return NodeRendererDefault;\n}(Component);\n\nNodeRendererDefault.defaultProps = {\n  isSearchMatch: false,\n  isSearchFocus: false,\n  canDrag: false,\n  toggleChildrenVisibility: null,\n  buttons: [],\n  className: '',\n  style: {},\n  parentNode: null,\n  draggedNode: null,\n  canDrop: false,\n  title: null,\n  subtitle: null,\n  rowDirection: 'ltr'\n};\nNodeRendererDefault.propTypes = {\n  node: PropTypes.shape({}).isRequired,\n  title: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  subtitle: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  path: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n  treeIndex: PropTypes.number.isRequired,\n  treeId: PropTypes.string.isRequired,\n  isSearchMatch: PropTypes.bool,\n  isSearchFocus: PropTypes.bool,\n  canDrag: PropTypes.bool,\n  scaffoldBlockPxWidth: PropTypes.number.isRequired,\n  toggleChildrenVisibility: PropTypes.func,\n  buttons: PropTypes.arrayOf(PropTypes.node),\n  className: PropTypes.string,\n  style: PropTypes.shape({}),\n  // Drag and drop API functions\n  // Drag source\n  connectDragPreview: PropTypes.func.isRequired,\n  connectDragSource: PropTypes.func.isRequired,\n  parentNode: PropTypes.shape({}),\n  // Needed for dndManager\n  isDragging: PropTypes.bool.isRequired,\n  didDrop: PropTypes.bool.isRequired,\n  draggedNode: PropTypes.shape({}),\n  // Drop target\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\n\nvar TreePlaceholder =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TreePlaceholder, _Component);\n\n  function TreePlaceholder() {\n    _classCallCheck(this, TreePlaceholder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TreePlaceholder).apply(this, arguments));\n  }\n\n  _createClass(TreePlaceholder, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          connectDropTarget = _this$props.connectDropTarget,\n          treeId = _this$props.treeId,\n          drop = _this$props.drop,\n          otherProps = _objectWithoutProperties(_this$props, [\"children\", \"connectDropTarget\", \"treeId\", \"drop\"]);\n\n      return connectDropTarget(React.createElement(\"div\", null, Children.map(children, function (child) {\n        return cloneElement(child, _objectSpread({}, otherProps));\n      })));\n    }\n  }]);\n\n  return TreePlaceholder;\n}(Component);\n\nTreePlaceholder.defaultProps = {\n  canDrop: false,\n  draggedNode: null\n};\nTreePlaceholder.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Drop target\n  connectDropTarget: PropTypes.func.isRequired,\n  isOver: PropTypes.bool.isRequired,\n  canDrop: PropTypes.bool,\n  draggedNode: PropTypes.shape({}),\n  treeId: PropTypes.string.isRequired,\n  drop: PropTypes.func.isRequired\n};\n\nvar PlaceholderRendererDefault = function PlaceholderRendererDefault(_ref) {\n  var isOver = _ref.isOver,\n      canDrop = _ref.canDrop;\n  return React.createElement(\"div\", {\n    className: classnames('rst__placeholder', canDrop && 'rst__placeholderLandingPad', canDrop && !isOver && 'rst__placeholderCancelPad')\n  });\n};\n\nPlaceholderRendererDefault.defaultProps = {\n  isOver: false,\n  canDrop: false\n};\nPlaceholderRendererDefault.propTypes = {\n  isOver: PropTypes.bool,\n  canDrop: PropTypes.bool\n};\n\nvar memoize = function memoize(f) {\n  var savedArgsArray = [];\n  var savedKeysArray = [];\n  var savedResult = null;\n  return function (args) {\n    var keysArray = Object.keys(args).sort();\n    var argsArray = keysArray.map(function (key) {\n      return args[key];\n    }); // If the arguments for the last insert operation are different than this time,\n    // recalculate the result\n\n    if (argsArray.length !== savedArgsArray.length || argsArray.some(function (arg, index) {\n      return arg !== savedArgsArray[index];\n    }) || keysArray.some(function (key, index) {\n      return key !== savedKeysArray[index];\n    })) {\n      savedArgsArray = argsArray;\n      savedKeysArray = keysArray;\n      savedResult = f(args);\n    }\n\n    return savedResult;\n  };\n};\n\nvar memoizedInsertNode = memoize(insertNode);\nvar memoizedGetFlatDataFromTree = memoize(getFlatDataFromTree);\nvar memoizedGetDescendantCount = memoize(getDescendantCount);\n\n/* eslint-disable import/prefer-default-export */\nfunction slideRows(rows, fromIndex, toIndex) {\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n  var rowsWithoutMoved = _toConsumableArray(rows.slice(0, fromIndex)).concat(_toConsumableArray(rows.slice(fromIndex + count)));\n\n  return _toConsumableArray(rowsWithoutMoved.slice(0, toIndex)).concat(_toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n}\n\nfunction defaultGetNodeKey(_ref) {\n  var treeIndex = _ref.treeIndex;\n  return treeIndex;\n} // Cheap hack to get the text of a react object\n\nfunction getReactElementText(parent) {\n  if (typeof parent === 'string') {\n    return parent;\n  }\n\n  if (parent === null || _typeof(parent) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n    return '';\n  }\n\n  if (typeof parent.props.children === 'string') {\n    return parent.props.children;\n  }\n\n  return parent.props.children.map(function (child) {\n    return getReactElementText(child);\n  }).join('');\n} // Search for a query string inside a node property\n\n\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n  if (typeof node[key] === 'function') {\n    // Search within text after calling its function to generate the text\n    return String(node[key]({\n      node: node,\n      path: path,\n      treeIndex: treeIndex\n    })).indexOf(searchQuery) > -1;\n  }\n\n  if (_typeof(node[key]) === 'object') {\n    // Search within text inside react elements\n    return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n  } // Search within string\n\n\n  return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n}\n\nfunction defaultSearchMethod(_ref2) {\n  var node = _ref2.node,\n      path = _ref2.path,\n      treeIndex = _ref2.treeIndex,\n      searchQuery = _ref2.searchQuery;\n  return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n}\n\nvar DndManager =\n/*#__PURE__*/\nfunction () {\n  function DndManager(treeRef) {\n    _classCallCheck(this, DndManager);\n\n    this.treeRef = treeRef;\n  }\n\n  _createClass(DndManager, [{\n    key: \"getTargetDepth\",\n    value: function getTargetDepth(dropTargetProps, monitor, component) {\n      var dropTargetDepth = 0;\n      var rowAbove = dropTargetProps.getPrevRow();\n\n      if (rowAbove) {\n        var path = rowAbove.path;\n        var aboveNodeCannotHaveChildren = !this.treeRef.canNodeHaveChildren(rowAbove.node);\n\n        if (aboveNodeCannotHaveChildren) {\n          path = path.slice(0, path.length - 1);\n        } // Limit the length of the path to the deepest possible\n\n\n        dropTargetDepth = Math.min(path.length, dropTargetProps.path.length);\n      }\n\n      var blocksOffset;\n      var dragSourceInitialDepth = (monitor.getItem().path || []).length; // When adding node from external source\n\n      if (monitor.getItem().treeId !== this.treeId) {\n        // Ignore the tree depth of the source, if it had any to begin with\n        dragSourceInitialDepth = 0;\n\n        if (component) {\n          var relativePosition = findDOMNode(component).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node\n\n          var leftShift = monitor.getSourceClientOffset().x - relativePosition.left;\n          blocksOffset = Math.round(leftShift / dropTargetProps.scaffoldBlockPxWidth);\n        } else {\n          blocksOffset = dropTargetProps.path.length;\n        }\n      } else {\n        // handle row direction support\n        var direction = dropTargetProps.rowDirection === 'rtl' ? -1 : 1;\n        blocksOffset = Math.round(direction * monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n      }\n\n      var targetDepth = Math.min(dropTargetDepth, Math.max(0, dragSourceInitialDepth + blocksOffset - 1)); // If a maxDepth is defined, constrain the target depth\n\n      if (typeof this.maxDepth !== 'undefined' && this.maxDepth !== null) {\n        var draggedNode = monitor.getItem().node;\n        var draggedChildDepth = getDepth(draggedNode);\n        targetDepth = Math.max(0, Math.min(targetDepth, this.maxDepth - draggedChildDepth - 1));\n      }\n\n      return targetDepth;\n    }\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dropTargetProps, monitor) {\n      if (!monitor.isOver()) {\n        return false;\n      }\n\n      var rowAbove = dropTargetProps.getPrevRow();\n      var abovePath = rowAbove ? rowAbove.path : [];\n      var aboveNode = rowAbove ? rowAbove.node : {};\n      var targetDepth = this.getTargetDepth(dropTargetProps, monitor, null); // Cannot drop if we're adding to the children of the row above and\n      //  the row above is a function\n\n      if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\n        return false;\n      }\n\n      if (typeof this.customCanDrop === 'function') {\n        var _monitor$getItem = monitor.getItem(),\n            node = _monitor$getItem.node;\n\n        var addedResult = memoizedInsertNode({\n          treeData: this.treeData,\n          newNode: node,\n          depth: targetDepth,\n          getNodeKey: this.getNodeKey,\n          minimumTreeIndex: dropTargetProps.listIndex,\n          expandParent: true\n        });\n        return this.customCanDrop({\n          node: node,\n          prevPath: monitor.getItem().path,\n          prevParent: monitor.getItem().parentNode,\n          prevTreeIndex: monitor.getItem().treeIndex,\n          // Equals -1 when dragged from external tree\n          nextPath: addedResult.path,\n          nextParent: addedResult.parentNode,\n          nextTreeIndex: addedResult.treeIndex\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: \"wrapSource\",\n    value: function wrapSource(el) {\n      var _this = this;\n\n      var nodeDragSource = {\n        beginDrag: function beginDrag(props) {\n          _this.startDrag(props);\n\n          return {\n            node: props.node,\n            parentNode: props.parentNode,\n            path: props.path,\n            treeIndex: props.treeIndex,\n            treeId: props.treeId\n          };\n        },\n        endDrag: function endDrag(props, monitor) {\n          _this.endDrag(monitor.getDropResult());\n        },\n        isDragging: function isDragging(props, monitor) {\n          var dropTargetNode = monitor.getItem().node;\n          var draggedNode = props.node;\n          return draggedNode === dropTargetNode;\n        }\n      };\n\n      function nodeDragSourcePropInjection(connect, monitor) {\n        return {\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n          didDrop: monitor.didDrop()\n        };\n      }\n\n      return DragSource(this.dndType, nodeDragSource, nodeDragSourcePropInjection)(el);\n    }\n  }, {\n    key: \"wrapTarget\",\n    value: function wrapTarget(el) {\n      var _this2 = this;\n\n      var nodeDropTarget = {\n        drop: function drop(dropTargetProps, monitor, component) {\n          var result = {\n            node: monitor.getItem().node,\n            path: monitor.getItem().path,\n            treeIndex: monitor.getItem().treeIndex,\n            treeId: _this2.treeId,\n            minimumTreeIndex: dropTargetProps.treeIndex,\n            depth: _this2.getTargetDepth(dropTargetProps, monitor, component)\n          };\n\n          _this2.drop(result);\n\n          return result;\n        },\n        hover: function hover(dropTargetProps, monitor, component) {\n          var targetDepth = _this2.getTargetDepth(dropTargetProps, monitor, component);\n\n          var draggedNode = monitor.getItem().node;\n          var needsRedraw = // Redraw if hovered above different nodes\n          dropTargetProps.node !== draggedNode || // Or hovered above the same node but at a different depth\n          targetDepth !== dropTargetProps.path.length - 1;\n\n          if (!needsRedraw) {\n            return;\n          } // throttle `dragHover` work to available animation frames\n\n\n          cancelAnimationFrame(_this2.rafId);\n          _this2.rafId = requestAnimationFrame(function () {\n            _this2.dragHover({\n              node: draggedNode,\n              path: monitor.getItem().path,\n              minimumTreeIndex: dropTargetProps.listIndex,\n              depth: targetDepth\n            });\n          });\n        },\n        canDrop: this.canDrop.bind(this)\n      };\n\n      function nodeDropTargetPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, nodeDropTarget, nodeDropTargetPropInjection)(el);\n    }\n  }, {\n    key: \"wrapPlaceholder\",\n    value: function wrapPlaceholder(el) {\n      var _this3 = this;\n\n      var placeholderDropTarget = {\n        drop: function drop(dropTargetProps, monitor) {\n          var _monitor$getItem2 = monitor.getItem(),\n              node = _monitor$getItem2.node,\n              path = _monitor$getItem2.path,\n              treeIndex = _monitor$getItem2.treeIndex;\n\n          var result = {\n            node: node,\n            path: path,\n            treeIndex: treeIndex,\n            treeId: _this3.treeId,\n            minimumTreeIndex: 0,\n            depth: 0\n          };\n\n          _this3.drop(result);\n\n          return result;\n        }\n      };\n\n      function placeholderPropInjection(connect, monitor) {\n        var dragged = monitor.getItem();\n        return {\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver(),\n          canDrop: monitor.canDrop(),\n          draggedNode: dragged ? dragged.node : null\n        };\n      }\n\n      return DropTarget(this.dndType, placeholderDropTarget, placeholderPropInjection)(el);\n    }\n  }, {\n    key: \"startDrag\",\n    get: function get() {\n      return this.treeRef.startDrag;\n    }\n  }, {\n    key: \"dragHover\",\n    get: function get() {\n      return this.treeRef.dragHover;\n    }\n  }, {\n    key: \"endDrag\",\n    get: function get() {\n      return this.treeRef.endDrag;\n    }\n  }, {\n    key: \"drop\",\n    get: function get() {\n      return this.treeRef.drop;\n    }\n  }, {\n    key: \"treeId\",\n    get: function get() {\n      return this.treeRef.treeId;\n    }\n  }, {\n    key: \"dndType\",\n    get: function get() {\n      return this.treeRef.dndType;\n    }\n  }, {\n    key: \"treeData\",\n    get: function get() {\n      return this.treeRef.state.draggingTreeData || this.treeRef.props.treeData;\n    }\n  }, {\n    key: \"getNodeKey\",\n    get: function get() {\n      return this.treeRef.props.getNodeKey;\n    }\n  }, {\n    key: \"customCanDrop\",\n    get: function get() {\n      return this.treeRef.props.canDrop;\n    }\n  }, {\n    key: \"maxDepth\",\n    get: function get() {\n      return this.treeRef.props.maxDepth;\n    }\n  }]);\n\n  return DndManager;\n}();\n\nvar treeIdCounter = 1;\n\nvar mergeTheme = function mergeTheme(props) {\n  var merged = _objectSpread({}, props, {\n    style: _objectSpread({}, props.theme.style, props.style),\n    innerStyle: _objectSpread({}, props.theme.innerStyle, props.innerStyle),\n    reactVirtualizedListProps: _objectSpread({}, props.theme.reactVirtualizedListProps, props.reactVirtualizedListProps)\n  });\n\n  var overridableDefaults = {\n    nodeContentRenderer: NodeRendererDefault,\n    placeholderRenderer: PlaceholderRendererDefault,\n    rowHeight: 62,\n    scaffoldBlockPxWidth: 44,\n    slideRegionSize: 100,\n    treeNodeRenderer: TreeNode\n  };\n  Object.keys(overridableDefaults).forEach(function (propKey) {\n    // If prop has been specified, do not change it\n    // If prop is specified in theme, use the theme setting\n    // If all else fails, fall back to the default\n    if (props[propKey] === null) {\n      merged[propKey] = typeof props.theme[propKey] !== 'undefined' ? props.theme[propKey] : overridableDefaults[propKey];\n    }\n  });\n  return merged;\n};\n\nvar ReactSortableTree =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ReactSortableTree, _Component);\n\n  function ReactSortableTree(props) {\n    var _this;\n\n    _classCallCheck(this, ReactSortableTree);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactSortableTree).call(this, props));\n\n    var _mergeTheme = mergeTheme(props),\n        dndType = _mergeTheme.dndType,\n        nodeContentRenderer = _mergeTheme.nodeContentRenderer,\n        treeNodeRenderer = _mergeTheme.treeNodeRenderer,\n        isVirtualized = _mergeTheme.isVirtualized,\n        slideRegionSize = _mergeTheme.slideRegionSize;\n\n    _this.dndManager = new DndManager(_assertThisInitialized(_assertThisInitialized(_this))); // Wrapping classes for use with react-dnd\n\n    _this.treeId = \"rst__\".concat(treeIdCounter);\n    treeIdCounter += 1;\n    _this.dndType = dndType || _this.treeId;\n    _this.nodeContentRenderer = _this.dndManager.wrapSource(nodeContentRenderer);\n    _this.treePlaceholderRenderer = _this.dndManager.wrapPlaceholder(TreePlaceholder);\n    _this.treeNodeRenderer = _this.dndManager.wrapTarget(treeNodeRenderer); // Prepare scroll-on-drag options for this list\n\n    if (isVirtualized) {\n      _this.scrollZoneVirtualList = (createScrollingComponent || withScrolling)(List);\n      _this.vStrength = createVerticalStrength(slideRegionSize);\n      _this.hStrength = createHorizontalStrength(slideRegionSize);\n    }\n\n    _this.state = {\n      draggingTreeData: null,\n      draggedNode: null,\n      draggedMinimumTreeIndex: null,\n      draggedDepth: null,\n      searchMatches: [],\n      searchFocusTreeIndex: null,\n      dragging: false,\n      // props that need to be used in gDSFP or static functions will be stored here\n      instanceProps: {\n        treeData: [],\n        ignoreOneTreeUpdate: false,\n        searchQuery: null,\n        searchFocusOffset: null\n      }\n    };\n    _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.moveNode = _this.moveNode.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.startDrag = _this.startDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dragHover = _this.dragHover.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.endDrag = _this.endDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.drop = _this.drop.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleDndMonitorChange = _this.handleDndMonitorChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(ReactSortableTree, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      ReactSortableTree.loadLazyChildren(this.props, this.state);\n      var stateUpdate = ReactSortableTree.search(this.props, this.state, true, true, false);\n      this.setState(stateUpdate); // Hook into react-dnd state changes to detect when the drag ends\n      // TODO: This is very brittle, so it needs to be replaced if react-dnd\n      // offers a more official way to detect when a drag ends\n\n      this.clearMonitorSubscription = this.props.dragDropManager.getMonitor().subscribeToStateChange(this.handleDndMonitorChange);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    // listen to dragging\n    value: function componentDidUpdate(prevProps, prevState) {\n      // if it is not the same then call the onDragStateChanged\n      if (this.state.dragging !== prevState.dragging) {\n        if (this.props.onDragStateChanged) {\n          this.props.onDragStateChanged({\n            isDragging: this.state.dragging,\n            draggedNode: this.state.draggedNode\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearMonitorSubscription();\n    }\n  }, {\n    key: \"getRows\",\n    value: function getRows(treeData) {\n      return memoizedGetFlatDataFromTree({\n        ignoreCollapsed: true,\n        getNodeKey: this.props.getNodeKey,\n        treeData: treeData\n      });\n    }\n  }, {\n    key: \"handleDndMonitorChange\",\n    value: function handleDndMonitorChange() {\n      var monitor = this.props.dragDropManager.getMonitor(); // If the drag ends and the tree is still in a mid-drag state,\n      // it means that the drag was canceled or the dragSource dropped\n      // elsewhere, and we should reset the state of this tree\n\n      if (!monitor.isDragging() && this.state.draggingTreeData) {\n        this.endDrag();\n      }\n    }\n  }, {\n    key: \"toggleChildrenVisibility\",\n    value: function toggleChildrenVisibility(_ref) {\n      var targetNode = _ref.node,\n          path = _ref.path;\n      var instanceProps = this.state.instanceProps;\n      var treeData = changeNodeAtPath({\n        treeData: instanceProps.treeData,\n        path: path,\n        newNode: function newNode(_ref2) {\n          var node = _ref2.node;\n          return _objectSpread({}, node, {\n            expanded: !node.expanded\n          });\n        },\n        getNodeKey: this.props.getNodeKey\n      });\n      this.props.onChange(treeData);\n      this.props.onVisibilityToggle({\n        treeData: treeData,\n        node: targetNode,\n        expanded: !targetNode.expanded,\n        path: path\n      });\n    }\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(_ref3) {\n      var node = _ref3.node,\n          prevPath = _ref3.path,\n          prevTreeIndex = _ref3.treeIndex,\n          depth = _ref3.depth,\n          minimumTreeIndex = _ref3.minimumTreeIndex;\n\n      var _insertNode = insertNode({\n        treeData: this.state.draggingTreeData,\n        newNode: node,\n        depth: depth,\n        minimumTreeIndex: minimumTreeIndex,\n        expandParent: true,\n        getNodeKey: this.props.getNodeKey\n      }),\n          treeData = _insertNode.treeData,\n          treeIndex = _insertNode.treeIndex,\n          path = _insertNode.path,\n          nextParentNode = _insertNode.parentNode;\n\n      this.props.onChange(treeData);\n      this.props.onMoveNode({\n        treeData: treeData,\n        node: node,\n        treeIndex: treeIndex,\n        path: path,\n        nextPath: path,\n        nextTreeIndex: treeIndex,\n        prevPath: prevPath,\n        prevTreeIndex: prevTreeIndex,\n        nextParentNode: nextParentNode\n      });\n    } // returns the new state after search\n\n  }, {\n    key: \"startDrag\",\n    value: function startDrag(_ref4) {\n      var _this2 = this;\n\n      var path = _ref4.path;\n      this.setState(function (prevState) {\n        var _removeNode = removeNode({\n          treeData: prevState.instanceProps.treeData,\n          path: path,\n          getNodeKey: _this2.props.getNodeKey\n        }),\n            draggingTreeData = _removeNode.treeData,\n            draggedNode = _removeNode.node,\n            draggedMinimumTreeIndex = _removeNode.treeIndex;\n\n        return {\n          draggingTreeData: draggingTreeData,\n          draggedNode: draggedNode,\n          draggedDepth: path.length - 1,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"dragHover\",\n    value: function dragHover(_ref5) {\n      var _this3 = this;\n\n      var draggedNode = _ref5.node,\n          draggedDepth = _ref5.depth,\n          draggedMinimumTreeIndex = _ref5.minimumTreeIndex;\n\n      // Ignore this hover if it is at the same position as the last hover\n      if (this.state.draggedDepth === draggedDepth && this.state.draggedMinimumTreeIndex === draggedMinimumTreeIndex) {\n        return;\n      }\n\n      this.setState(function (_ref6) {\n        var draggingTreeData = _ref6.draggingTreeData,\n            instanceProps = _ref6.instanceProps;\n        // Fall back to the tree data if something is being dragged in from\n        //  an external element\n        var newDraggingTreeData = draggingTreeData || instanceProps.treeData;\n        var addedResult = memoizedInsertNode({\n          treeData: newDraggingTreeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: _this3.props.getNodeKey\n        });\n\n        var rows = _this3.getRows(addedResult.treeData);\n\n        var expandedParentPath = rows[addedResult.treeIndex].path;\n        return {\n          draggedNode: draggedNode,\n          draggedDepth: draggedDepth,\n          draggedMinimumTreeIndex: draggedMinimumTreeIndex,\n          draggingTreeData: changeNodeAtPath({\n            treeData: newDraggingTreeData,\n            path: expandedParentPath.slice(0, -1),\n            newNode: function newNode(_ref7) {\n              var node = _ref7.node;\n              return _objectSpread({}, node, {\n                expanded: true\n              });\n            },\n            getNodeKey: _this3.props.getNodeKey\n          }),\n          // reset the scroll focus so it doesn't jump back\n          // to a search result while dragging\n          searchFocusTreeIndex: null,\n          dragging: true\n        };\n      });\n    }\n  }, {\n    key: \"endDrag\",\n    value: function endDrag(dropResult) {\n      var _this4 = this;\n\n      var instanceProps = this.state.instanceProps;\n\n      var resetTree = function resetTree() {\n        return _this4.setState({\n          draggingTreeData: null,\n          draggedNode: null,\n          draggedMinimumTreeIndex: null,\n          draggedDepth: null,\n          dragging: false\n        });\n      }; // Drop was cancelled\n\n\n      if (!dropResult) {\n        resetTree();\n      } else if (dropResult.treeId !== this.treeId) {\n        // The node was dropped in an external drop target or tree\n        var node = dropResult.node,\n            path = dropResult.path,\n            treeIndex = dropResult.treeIndex;\n        var shouldCopy = this.props.shouldCopyOnOutsideDrop;\n\n        if (typeof shouldCopy === 'function') {\n          shouldCopy = shouldCopy({\n            node: node,\n            prevTreeIndex: treeIndex,\n            prevPath: path\n          });\n        }\n\n        var treeData = this.state.draggingTreeData || instanceProps.treeData; // If copying is enabled, a drop outside leaves behind a copy in the\n        //  source tree\n\n        if (shouldCopy) {\n          treeData = changeNodeAtPath({\n            treeData: instanceProps.treeData,\n            // use treeData unaltered by the drag operation\n            path: path,\n            newNode: function newNode(_ref8) {\n              var copyNode = _ref8.node;\n              return _objectSpread({}, copyNode);\n            },\n            // create a shallow copy of the node\n            getNodeKey: this.props.getNodeKey\n          });\n        }\n\n        this.props.onChange(treeData);\n        this.props.onMoveNode({\n          treeData: treeData,\n          node: node,\n          treeIndex: null,\n          path: null,\n          nextPath: null,\n          nextTreeIndex: null,\n          prevPath: path,\n          prevTreeIndex: treeIndex\n        });\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(dropResult) {\n      this.moveNode(dropResult);\n    }\n  }, {\n    key: \"canNodeHaveChildren\",\n    value: function canNodeHaveChildren(node) {\n      var canNodeHaveChildren = this.props.canNodeHaveChildren;\n\n      if (canNodeHaveChildren) {\n        return canNodeHaveChildren(node);\n      }\n\n      return true;\n    } // Load any children in the tree that are given by a function\n    // calls the onChange callback on the new treeData\n\n  }, {\n    key: \"renderRow\",\n    value: function renderRow(row, _ref9) {\n      var listIndex = _ref9.listIndex,\n          style = _ref9.style,\n          getPrevRow = _ref9.getPrevRow,\n          matchKeys = _ref9.matchKeys,\n          swapFrom = _ref9.swapFrom,\n          swapDepth = _ref9.swapDepth,\n          swapLength = _ref9.swapLength;\n      var node = row.node,\n          parentNode = row.parentNode,\n          path = row.path,\n          lowerSiblingCounts = row.lowerSiblingCounts,\n          treeIndex = row.treeIndex;\n\n      var _mergeTheme2 = mergeTheme(this.props),\n          canDrag = _mergeTheme2.canDrag,\n          generateNodeProps = _mergeTheme2.generateNodeProps,\n          scaffoldBlockPxWidth = _mergeTheme2.scaffoldBlockPxWidth,\n          searchFocusOffset = _mergeTheme2.searchFocusOffset,\n          rowDirection = _mergeTheme2.rowDirection;\n\n      var TreeNodeRenderer = this.treeNodeRenderer;\n      var NodeContentRenderer = this.nodeContentRenderer;\n      var nodeKey = path[path.length - 1];\n      var isSearchMatch = nodeKey in matchKeys;\n      var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\n      var callbackParams = {\n        node: node,\n        parentNode: parentNode,\n        path: path,\n        lowerSiblingCounts: lowerSiblingCounts,\n        treeIndex: treeIndex,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus\n      };\n      var nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\n      var rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\n      var sharedProps = {\n        treeIndex: treeIndex,\n        scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n        node: node,\n        path: path,\n        treeId: this.treeId,\n        rowDirection: rowDirection\n      };\n      return React.createElement(TreeNodeRenderer, _extends({\n        style: style,\n        key: nodeKey,\n        listIndex: listIndex,\n        getPrevRow: getPrevRow,\n        lowerSiblingCounts: lowerSiblingCounts,\n        swapFrom: swapFrom,\n        swapLength: swapLength,\n        swapDepth: swapDepth\n      }, sharedProps), React.createElement(NodeContentRenderer, _extends({\n        parentNode: parentNode,\n        isSearchMatch: isSearchMatch,\n        isSearchFocus: isSearchFocus,\n        canDrag: rowCanDrag,\n        toggleChildrenVisibility: this.toggleChildrenVisibility\n      }, sharedProps, nodeProps)));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _mergeTheme3 = mergeTheme(this.props),\n          dragDropManager = _mergeTheme3.dragDropManager,\n          style = _mergeTheme3.style,\n          className = _mergeTheme3.className,\n          innerStyle = _mergeTheme3.innerStyle,\n          rowHeight = _mergeTheme3.rowHeight,\n          isVirtualized = _mergeTheme3.isVirtualized,\n          placeholderRenderer = _mergeTheme3.placeholderRenderer,\n          reactVirtualizedListProps = _mergeTheme3.reactVirtualizedListProps,\n          getNodeKey = _mergeTheme3.getNodeKey,\n          rowDirection = _mergeTheme3.rowDirection;\n\n      var _this$state = this.state,\n          searchMatches = _this$state.searchMatches,\n          searchFocusTreeIndex = _this$state.searchFocusTreeIndex,\n          draggedNode = _this$state.draggedNode,\n          draggedDepth = _this$state.draggedDepth,\n          draggedMinimumTreeIndex = _this$state.draggedMinimumTreeIndex,\n          instanceProps = _this$state.instanceProps;\n      var treeData = this.state.draggingTreeData || instanceProps.treeData;\n      var rowDirectionClass = rowDirection === 'rtl' ? 'rst__rtl' : null;\n      var rows;\n      var swapFrom = null;\n      var swapLength = null;\n\n      if (draggedNode && draggedMinimumTreeIndex !== null) {\n        var addedResult = memoizedInsertNode({\n          treeData: treeData,\n          newNode: draggedNode,\n          depth: draggedDepth,\n          minimumTreeIndex: draggedMinimumTreeIndex,\n          expandParent: true,\n          getNodeKey: getNodeKey\n        });\n        var swapTo = draggedMinimumTreeIndex;\n        swapFrom = addedResult.treeIndex;\n        swapLength = 1 + memoizedGetDescendantCount({\n          node: draggedNode\n        });\n        rows = slideRows(this.getRows(addedResult.treeData), swapFrom, swapTo, swapLength);\n      } else {\n        rows = this.getRows(treeData);\n      } // Get indices for rows that match the search conditions\n\n\n      var matchKeys = {};\n      searchMatches.forEach(function (_ref10, i) {\n        var path = _ref10.path;\n        matchKeys[path[path.length - 1]] = i;\n      }); // Seek to the focused search result if there is one specified\n\n      var scrollToInfo = searchFocusTreeIndex !== null ? {\n        scrollToIndex: searchFocusTreeIndex\n      } : {};\n      var containerStyle = style;\n      var list;\n\n      if (rows.length < 1) {\n        var Placeholder = this.treePlaceholderRenderer;\n        var PlaceholderContent = placeholderRenderer;\n        list = React.createElement(Placeholder, {\n          treeId: this.treeId,\n          drop: this.drop\n        }, React.createElement(PlaceholderContent, null));\n      } else if (isVirtualized) {\n        containerStyle = _objectSpread({\n          height: '100%'\n        }, containerStyle);\n        var ScrollZoneVirtualList = this.scrollZoneVirtualList; // Render list with react-virtualized\n\n        list = React.createElement(AutoSizer, null, function (_ref11) {\n          var height = _ref11.height,\n              width = _ref11.width;\n          return React.createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {\n            dragDropManager: dragDropManager,\n            verticalStrength: _this5.vStrength,\n            horizontalStrength: _this5.hStrength,\n            speed: 30,\n            scrollToAlignment: \"start\",\n            className: \"rst__virtualScrollOverride\",\n            width: width,\n            onScroll: function onScroll(_ref12) {\n              var scrollTop = _ref12.scrollTop;\n              _this5.scrollTop = scrollTop;\n            },\n            height: height,\n            style: innerStyle,\n            rowCount: rows.length,\n            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,\n            rowHeight: typeof rowHeight !== 'function' ? rowHeight : function (_ref13) {\n              var index = _ref13.index;\n              return rowHeight({\n                index: index,\n                treeIndex: index,\n                node: rows[index].node,\n                path: rows[index].path\n              });\n            },\n            rowRenderer: function rowRenderer(_ref14) {\n              var index = _ref14.index,\n                  rowStyle = _ref14.style;\n              return _this5.renderRow(rows[index], {\n                listIndex: index,\n                style: rowStyle,\n                getPrevRow: function getPrevRow() {\n                  return rows[index - 1] || null;\n                },\n                matchKeys: matchKeys,\n                swapFrom: swapFrom,\n                swapDepth: draggedDepth,\n                swapLength: swapLength\n              });\n            }\n          }, reactVirtualizedListProps));\n        });\n      } else {\n        // Render list without react-virtualized\n        list = rows.map(function (row, index) {\n          return _this5.renderRow(row, {\n            listIndex: index,\n            style: {\n              height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({\n                index: index,\n                treeIndex: index,\n                node: row.node,\n                path: row.path\n              })\n            },\n            getPrevRow: function getPrevRow() {\n              return rows[index - 1] || null;\n            },\n            matchKeys: matchKeys,\n            swapFrom: swapFrom,\n            swapDepth: draggedDepth,\n            swapLength: swapLength\n          });\n        });\n      }\n\n      return React.createElement(\"div\", {\n        className: classnames('rst__tree', className, rowDirectionClass),\n        style: containerStyle\n      }, list);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var instanceProps = prevState.instanceProps;\n      var newState = {};\n      var isTreeDataEqual = isEqual(instanceProps.treeData, nextProps.treeData); // make sure we have the most recent version of treeData\n\n      instanceProps.treeData = nextProps.treeData;\n\n      if (!isTreeDataEqual) {\n        if (instanceProps.ignoreOneTreeUpdate) {\n          instanceProps.ignoreOneTreeUpdate = false;\n        } else {\n          newState.searchFocusTreeIndex = null;\n          ReactSortableTree.loadLazyChildren(nextProps, prevState);\n          Object.assign(newState, ReactSortableTree.search(nextProps, prevState, false, false, false));\n        }\n\n        newState.draggingTreeData = null;\n        newState.draggedNode = null;\n        newState.draggedMinimumTreeIndex = null;\n        newState.draggedDepth = null;\n        newState.dragging = false;\n      } else if (!isEqual(instanceProps.searchQuery, nextProps.searchQuery)) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, false));\n      } else if (instanceProps.searchFocusOffset !== nextProps.searchFocusOffset) {\n        Object.assign(newState, ReactSortableTree.search(nextProps, prevState, true, true, true));\n      }\n\n      instanceProps.searchQuery = nextProps.searchQuery;\n      instanceProps.searchFocusOffset = nextProps.searchFocusOffset;\n      newState.instanceProps = instanceProps;\n      return newState;\n    }\n  }, {\n    key: \"search\",\n    value: function search(props, state, seekIndex, expand, singleSearch) {\n      var onChange = props.onChange,\n          getNodeKey = props.getNodeKey,\n          searchFinishCallback = props.searchFinishCallback,\n          searchQuery = props.searchQuery,\n          searchMethod = props.searchMethod,\n          searchFocusOffset = props.searchFocusOffset,\n          onlyExpandSearchedNodes = props.onlyExpandSearchedNodes;\n      var instanceProps = state.instanceProps; // Skip search if no conditions are specified\n\n      if (!searchQuery && !searchMethod) {\n        if (searchFinishCallback) {\n          searchFinishCallback([]);\n        }\n\n        return {\n          searchMatches: []\n        };\n      }\n\n      var newState = {}; // if onlyExpandSearchedNodes collapse the tree and search\n\n      var _find = find({\n        getNodeKey: getNodeKey,\n        treeData: onlyExpandSearchedNodes ? toggleExpandedForAll({\n          treeData: instanceProps.treeData,\n          expanded: false\n        }) : instanceProps.treeData,\n        searchQuery: searchQuery,\n        searchMethod: searchMethod || defaultSearchMethod,\n        searchFocusOffset: searchFocusOffset,\n        expandAllMatchPaths: expand && !singleSearch,\n        expandFocusMatchPaths: !!expand\n      }),\n          expandedTreeData = _find.treeData,\n          searchMatches = _find.matches; // Update the tree with data leaving all paths leading to matching nodes open\n\n\n      if (expand) {\n        newState.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\n        onChange(expandedTreeData);\n      }\n\n      if (searchFinishCallback) {\n        searchFinishCallback(searchMatches);\n      }\n\n      var searchFocusTreeIndex = null;\n\n      if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n        searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n      }\n\n      newState.searchMatches = searchMatches;\n      newState.searchFocusTreeIndex = searchFocusTreeIndex;\n      return newState;\n    }\n  }, {\n    key: \"loadLazyChildren\",\n    value: function loadLazyChildren(props, state) {\n      var instanceProps = state.instanceProps;\n      walk({\n        treeData: instanceProps.treeData,\n        getNodeKey: props.getNodeKey,\n        callback: function callback(_ref15) {\n          var node = _ref15.node,\n              path = _ref15.path,\n              lowerSiblingCounts = _ref15.lowerSiblingCounts,\n              treeIndex = _ref15.treeIndex;\n\n          // If the node has children defined by a function, and is either expanded\n          //  or set to load even before expansion, run the function.\n          if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n            // Call the children fetching function\n            node.children({\n              node: node,\n              path: path,\n              lowerSiblingCounts: lowerSiblingCounts,\n              treeIndex: treeIndex,\n              // Provide a helper to append the new data when it is received\n              done: function done(childrenArray) {\n                return props.onChange(changeNodeAtPath({\n                  treeData: instanceProps.treeData,\n                  path: path,\n                  newNode: function newNode(_ref16) {\n                    var oldNode = _ref16.node;\n                    return (// Only replace the old node if it's the one we set off to find children\n                      //  for in the first place\n                      oldNode === node ? _objectSpread({}, oldNode, {\n                        children: childrenArray\n                      }) : oldNode\n                    );\n                  },\n                  getNodeKey: props.getNodeKey\n                }));\n              }\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReactSortableTree;\n}(Component);\n\nReactSortableTree.propTypes = {\n  dragDropManager: PropTypes.shape({\n    getMonitor: PropTypes.func\n  }).isRequired,\n  // Tree data in the following format:\n  // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n  // `title` is the primary label for the node\n  // `subtitle` is a secondary label for the node\n  // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n  // `children` is an array of child nodes belonging to the node.\n  treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\n  // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n  style: PropTypes.shape({}),\n  // Class name for the container wrapping the tree\n  className: PropTypes.string,\n  // Style applied to the inner, scrollable container (for padding, etc.)\n  innerStyle: PropTypes.shape({}),\n  // Used by react-virtualized\n  // Either a fixed row height (number) or a function that returns the\n  // height of a row given its index: `({ index: number }): number`\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  // Size in px of the region near the edges that initiates scrolling on dragover\n  slideRegionSize: PropTypes.number,\n  // Custom properties to hand to the react-virtualized list\n  // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n  reactVirtualizedListProps: PropTypes.shape({}),\n  // The width of the blocks containing the lines representing the structure of the tree.\n  scaffoldBlockPxWidth: PropTypes.number,\n  // Maximum depth nodes can be inserted at. Defaults to infinite.\n  maxDepth: PropTypes.number,\n  // The method used to search nodes.\n  // Defaults to a function that uses the `searchQuery` string to search for nodes with\n  // matching `title` or `subtitle` values.\n  // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n  searchMethod: PropTypes.func,\n  // Used by the `searchMethod` to highlight and scroll to matched nodes.\n  // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n  searchQuery: PropTypes.any,\n  // eslint-disable-line react/forbid-prop-types\n  // Outline the <`searchFocusOffset`>th node and scroll to it.\n  searchFocusOffset: PropTypes.number,\n  // Get the nodes that match the search criteria. Used for counting total matches, etc.\n  searchFinishCallback: PropTypes.func,\n  // Generate an object with additional props to be passed to the node renderer.\n  // Use this for adding buttons via the `buttons` key,\n  // or additional `style` / `className` settings.\n  generateNodeProps: PropTypes.func,\n  // Set to false to disable virtualization.\n  // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\n  isVirtualized: PropTypes.bool,\n  treeNodeRenderer: PropTypes.func,\n  // Override the default component for rendering nodes (but keep the scaffolding generator)\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n  nodeContentRenderer: PropTypes.func,\n  // Override the default component for rendering an empty tree\n  // This is an advanced option for complete customization of the appearance.\n  // It is best to copy the component in `placeholder-renderer-default.js` to use as a base,\n  // and customize as needed.\n  placeholderRenderer: PropTypes.func,\n  theme: PropTypes.shape({\n    style: PropTypes.shape({}),\n    innerStyle: PropTypes.shape({}),\n    reactVirtualizedListProps: PropTypes.shape({}),\n    scaffoldBlockPxWidth: PropTypes.number,\n    slideRegionSize: PropTypes.number,\n    rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n    treeNodeRenderer: PropTypes.func,\n    nodeContentRenderer: PropTypes.func,\n    placeholderRenderer: PropTypes.func\n  }),\n  // Determine the unique key used to identify each node and\n  // generate the `path` array passed in callbacks.\n  // By default, returns the index in the tree (omitting hidden nodes).\n  getNodeKey: PropTypes.func,\n  // Called whenever tree data changed.\n  // Just like with React input elements, you have to update your\n  // own component's data to see the changes reflected.\n  onChange: PropTypes.func.isRequired,\n  // Called after node move operation.\n  onMoveNode: PropTypes.func,\n  // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\n  canDrag: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Determine whether a node can be dropped based on its path and parents'.\n  canDrop: PropTypes.func,\n  // Determine whether a node can have children\n  canNodeHaveChildren: PropTypes.func,\n  // When true, or a callback returning true, dropping nodes to react-dnd\n  // drop targets outside of this tree will not remove them from this tree\n  shouldCopyOnOutsideDrop: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  // Called after children nodes collapsed or expanded.\n  onVisibilityToggle: PropTypes.func,\n  dndType: PropTypes.string,\n  // Called to track between dropped and dragging\n  onDragStateChanged: PropTypes.func,\n  // Specify that nodes that do not match search will be collapsed\n  onlyExpandSearchedNodes: PropTypes.bool,\n  // rtl support\n  rowDirection: PropTypes.string\n};\nReactSortableTree.defaultProps = {\n  canDrag: true,\n  canDrop: null,\n  canNodeHaveChildren: function canNodeHaveChildren() {\n    return true;\n  },\n  className: '',\n  dndType: null,\n  generateNodeProps: null,\n  getNodeKey: defaultGetNodeKey,\n  innerStyle: {},\n  isVirtualized: true,\n  maxDepth: null,\n  treeNodeRenderer: null,\n  nodeContentRenderer: null,\n  onMoveNode: function onMoveNode() {},\n  onVisibilityToggle: function onVisibilityToggle() {},\n  placeholderRenderer: null,\n  reactVirtualizedListProps: {},\n  rowHeight: null,\n  scaffoldBlockPxWidth: null,\n  searchFinishCallback: null,\n  searchFocusOffset: null,\n  searchMethod: null,\n  searchQuery: null,\n  shouldCopyOnOutsideDrop: false,\n  slideRegionSize: null,\n  style: {},\n  theme: {},\n  onDragStateChanged: function onDragStateChanged() {},\n  onlyExpandSearchedNodes: false,\n  rowDirection: 'ltr'\n};\npolyfill(ReactSortableTree);\n\nvar SortableTreeWithoutDndContext = function SortableTreeWithoutDndContext(props) {\n  return React.createElement(DndContext.Consumer, null, function (_ref17) {\n    var dragDropManager = _ref17.dragDropManager;\n    return dragDropManager === undefined ? null : React.createElement(ReactSortableTree, _extends({}, props, {\n      dragDropManager: dragDropManager\n    }));\n  });\n};\n\nvar SortableTree = function SortableTree(props) {\n  return React.createElement(DndProvider, {\n    backend: HTML5Backend\n  }, React.createElement(SortableTreeWithoutDndContext, props));\n}; // Export the tree component without the react-dnd DragDropContext,\n\nexport default SortableTree;\nexport { SortableTreeWithoutDndContext, defaultGetNodeKey, defaultSearchMethod, getDescendantCount, getVisibleNodeCount, getVisibleNodeInfoAtIndex, walk, map, toggleExpandedForAll, changeNodeAtPath, removeNodeAtPath, removeNode, getNodeAtPath, addNodeUnderParent, insertNode, getFlatDataFromTree, getTreeFromFlatData, isDescendant, getDepth, find };\n"]},"metadata":{},"sourceType":"module"}